# 1. 概述
- Java字节码对于虚拟机，就类似汇编语言对于计算机，属于基本执行指令
- Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为**操作码，Opcode**）以及跟随其后的零至多个代表此操作所需参数（称为**操作数，Operands**）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码
- 由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着**指令集的操作码总数不可能超过256条**（参考文档 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html）
- 熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此阅读字节码是了解Java虚拟机的基础技能，需要熟练掌握常见指令
## 1.1 执行模型
如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解：
```java
do {
    自动计算PC寄存器的值加1；
    根据PC寄存器的指示位置，从字节码流中取出操作码；
    if (字节码存在操作数) 从字节码流中取出操作数；
    执行操作码所定义的操作；
} while (字节码长度 > 0)
```
## 1.2 字节码与数据类型
- 在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，`iload`指令用于从局部变量表中加载int型的数据到操作数栈中，而`fload`指令加载的则是float类型的数据
- 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：
    - `i`代表`int`类型
    - `l`代表`long`类型
    - `s`代表`short`类型
    - `b`代表`byte`类型
    - `c`代表`char`类型
    - `f`代表`float`类型
    - `d`代表`double`类型
- 也有一些指令的助记符中没有明确地指明操作类型的字母，如`arraylength`指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令`goto`则是与数据类型无关的
- 大部分的指令都没有支持整数类型`byte`、`char`和`short`，甚至没有任何指令支持`boolean`类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的`int`类型数据。与之类似，在处理`boolean`、`byte`、`short`、`char`类型的数组时，也会转换为使用`int`类型的字节码指令来处理。因此，大多数对于`boolean`、`byte`、`short`、`char`类型数据的操作，实际上都是使用相应的`int`类型作为运算类型
## 1.3 指令分类
- JVM中的字节码指令集按用途大致分为9类
    - 加载与存储指令
    - 算数指令
    - 类型转换指令
    - 对象的创建于访问指令
    - 方法调用与返回指令
    - 操作数栈管理指令
    - 比较控制指令
    - 异常处理指令
    - 同步控制指令
- 在做值相关操作时：
    - 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是指，也可能是对象的引用）被压入操作数栈
    - 一个指令，也可以从操作数栈中取出一个到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等操作
    
# 2. 加载与存储指令
> 作用
> 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递
> 常用指令
- **局部变量压栈指令**：将一个局部变量加载到操作数栈。`xload`、`xload_<n>`（其中`x`为`i`、`l`、`f`、`d`、`a`；`n`为`0~3`）
- **常量入栈指令**：将一个常量加载到操作数栈：`bipush`、`sipush`、`ldc`、`ldc_w`、`ldc2_w`、`aconst_null`、`iconst_m1`、`iconst_<i>`、`lconst_<l>`、`fconst_<f>`、`dconst_<d>`
- **出栈装入局部变量表指令** ：将一个数值从操作数栈存储到局部变量表：`xstore`、`xstore_<n>`(其中`x`为`i`、`l`、`f`、`d`、`a`；`n`为`0~3`）、`xastore`（）其中`x`为`i`、`l`、`f`、`d`、`a`、`b`、`c`、`s`）
- 扩充局部变量表的访问索引的指令：`wide`

上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如`iload_<n>`）。这些指令助记符实际上代表了一组指令（例如`iload_<n>`代表了`iload_0`、`iload_1`、`iload_2`、`iload_3`这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如`iload`）的特殊形式。**对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。**

除此之外，它们的语义与原生的通用指令完全一致（例如`iload_0`的语义与操作数为0时的`iload`指令语义完全一致，表示将局部变量表中索引为0位置上的数据压入操作数栈中）。在尖括号之间的字母制定了指令隐含的操作数的数据类型，`<n>`代表非负的整数，`<i>`代表是`int`类型数据，`<l>`代表`long`类型，`<f>`代表`float`类型，`<d>`代表`double`类型。操作`byte`、`char`、`short`和`boolean`类型数据时，经常用`int`类型的指令来表示

## 2.1 局部变量压栈指令
**局部变量压栈指令将给定的局部变量表中的数据压入操作数栈**。这类指令大体可以分为：
- `xload_<n>`（其中`x`为`i`、`l`、`f`、`d`、`a`；`n`为`0~3`）
- `xload`（其中`x`为`i`、`l`、`f`、`d`、`a`）
说明：在这里`x`的取值表示数据类型。

指令`xload_n`表示将第n个局部变量压入操作数栈，比如`iload_1`、`fload_0`、`aload_0`等指令。其中`aload_n`表示将一个对象引用压栈；指令`xload`通过制定参数的形式，把局部变量压入操作数栈，当使用这个指令时，表示局部变量的数量可能超过了4个，比如指令`iload`、`fload`等 

## 2.2 常量入栈指令
**常量入栈指令的功能是将常数压入操作数栈**，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc系列
- **const系列**：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：`iconst_<i>`（`i`范围`-1 ~ 5`）、`lconst_<l>`（`l`范围`0 ~ 1`）、`fconst_<f>`（`f`范围`0 ~ 2`）、`dconst_<d>`（`d`范围`0 ~ 1`）、`aconst_null`，比如：
    - `iconst_m1`将`-1`压入操作数栈
    - `iconst_x`（`x`为`0 ~ 5`）将x压入栈
    - `lconst_0`、`lconst_1`分别将长整数0和1压入栈
    - `fconst_0`、`fconst_1`、`fconst_2`分别将浮点数0、1、2压入栈
    - `dconst_0`、`dconst_1`分别将`double`型0和1压入栈
    - `aconst_null`将null压入栈
    

从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，`i`表示整数，`l`表示长整数，`f`表示浮点数，`d`表示双精度浮点，习惯上用`a`表示对象引用。如果指令隐含操作的参数，会以下划线形式给出
- **push系列**：主要包括`bipush`和`sipush`，它们的区别在于接收数据类型的不同，`bipush`接收`8`位整数作为参数，`sipush`接收`16`位整数，它们都将参数压入栈
- **ldc系列**：如果以上指令都不能满足需求，那么可以使用万能的`ldc`指令，该指令可以接收**一个`8`位**的参数，该参数指向常量池中的`int`、`float`或者`string`的索引，将指定的内容压入堆栈。
    - 类似的还有`ldc_w`，它接收**两个`8`位**的参数，能支持的索引范围大于`ldc`。
    - 如果要压入的元素是`long`或者`double`类型的，则使用`ldc2_w`指令，使用方式都是类似的

> 举例 1
```java
// 常量入栈指令
public void pushConstLdc() {
    int i = -1;
    int a = 5;
    int b = 6;
    int c = 127;
    int d = 128;
    int e = 32767;
    int f = 32768;
}
```
字节码指令如下：
```java
 0 iconst_m1
 1 istore_1
 2 iconst_5
 3 istore_2
 4 bipush 6
 6 istore_3
 7 bipush 127
 9 istore 4
11 sipush 128
14 istore 5
16 sipush 32767
19 istore 6
21 ldc #7 <32768>
23 istore 7
25 return
```
> 举例 2
```java
public void constLdc() {
    long a1 = 1;
    long a2 = 2;
    float b1 = 2;
    float b2 = 3;
    double c1 = 1;
    double c2 = 2;
    Date d = null;
}
```
字节码指令如下：
```java
 0 lconst_1
 1 lstore_1
 2 ldc2_w #8 <2>
 5 lstore_3
 6 fconst_2
 7 fstore 5
 9 ldc #10 <3.0>
11 fstore 6
13 dconst_1
14 dstore 7
16 ldc2_w #11 <2.0>
19 dstore 9
21 aconst_null
22 astore 11
24 return
```

> 总结

| 类型                             | 常数指令 | 范围                          |
| -------------------------------- | -------- | ----------------------------- |
| int (boolean, byte, char, short) | iconst   | [-1, 5]                       |
|                                  | bipush   | [-128, 127]                   |
|                                  | sipush   | [-32768, 32767]               |
|                                  | ldc      | any int value                 |
| long                             | lconst   | 0, 1                          |
|                                  | ldc      | any long value                |
| float                            | fconst   | 0, 1, 2                       |
|                                  | ldc      | any float value               |
| double                           | dconst   | 0, 1                          |
|                                  | ldc      | any double value              |
| reference                        | aconst   | null                          |
|                                  | ldc      | String literal, Class literal |

## 2.3 出栈装入局部变量表指令
出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以`store`的形式存在，比如`xstore`（`x`为`i`、`l`、`f`、`d`、`a`）、`xstore_n`（`x`为`i`、`l`、`f`、`d`、`a`；`n`范围`0 ~ 3`）。其中
    - 指令`istore_n`将从操作数栈中弹出一个整数，并把它赋值给局部变量索引`n`的位置
    - 指令`xstore`由于没有隐含参数信息，故需要提供一个`byte`类型的参数类指定目标局部变量表的位置。
> 说明
> 一般来说，类似像`store`这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是为了尽可能压缩指令大小，使用专门的`istore_1`指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有`istore_0`、`istore_2`、`istore_3`，他们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置

由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码提及。如果局部变量表很大，需要存储的槽位大于3，那么可以使用`istore`执行，额外加一个参数，用来表示需要存放的槽位位置

> 举例 1
```java
public void store(int k, double d) {
    int m = k + 2;
    long l = 12;
    String str = "nasuf";
    float f = 10.0f;
    d = 10;
}
```
字节码指令如下：
```java
 0 iload_1
 1 iconst_2
 2 iadd
 3 istore 4
 5 ldc2_w #13 <12>
 8 lstore 5
10 ldc #15 <nasuf>
12 astore 7
14 ldc #16 <10.0>
16 fstore 8
18 ldc2_w #17 <10.0>
21 dstore_2
22 return
```
> 举例 2
```java
public void foo(long l, float f) {
    {
        int i = 0;
    }
    {
        String s = "nasuf";
    }
}
```
字节码指令入如下：
```java
0 iconst_0
1 istore 4
3 ldc #15 <nasuf>
5 astore 4 // 槽位复用
7 return
```

# 3. 算术指令
> 作用
> 算术指令用于对两个操作数栈上的值进行某种特定运算，**并把结果重新压入操作数栈**
> 分类
> 算术指令可以分为两种：对**整型数据**进行运算的指令和对**浮点类型**进行运算的指令
> byte、short、char和boolean类型说明
> 在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都是用int类型的指令来处理。此外在处理byte、short、char和boolean类型的数组时，也会转换为使用对应的int类型的字节码指令来处理

| 实际类型      | 运算类型      |
| ------------- | ------------- |
| boolean       | int           |
| byte          | int           |
| char          | int           |
| short         | int           |
| int           | int           |
| float         | float         |
| reference     | reference     |
| returnAddress | returnAddress |
| long          | long          |
| double        | double        |
> 运算时的溢出
> 数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中，当出现除以0时会导致虚拟机抛出异常`ArithmeticException`
> 运算模式
- **向最接近数舍入模式**：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的
- **向零舍入模式**：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果
> NaN值的使用
> 当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用`NaN`值来表示。而且所有使用`NaN`值作为操作数的算术操作，结果都会返回`NaN`

> 代码测试
```java
public void method1() {
    int i = 10;
    // int j = i / 0;  // java.lang.ArithmeticException: / by zero
    double j = i / 0.0;
    System.out.println(j);  // Infinity

    double d1 = 0.0;
    double d2 = d1 / 0.0;
    System.out.println(d2); // NaN
}
```
## 3.1 所有算术指令
- 加法指令：iadd、ladd、fadd、dadd
- 减法指令：isub、lsub、fsub、dsub
- 乘法指令：imul、lmul、fmul、dmul
- 除法指令：idiv、ldiv、fdiv、ddiv
- 求余指令：irem、lrem、frem、drem  // remainder：余数
- 取反指令：ineg、lneg、fneg、dneg
- 自增指令：iinc
- 位运算指令
    - 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
    - 按位或指令：ior、lor
    - 按位与指令：iand、land
    - 按位异或指令：ixor、lxor
- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
### 3.1.1 代码举例
> 代码 1
```java
public void method2() {
    float i = 10;
    float j = -i;
    i = -j;
}
```
对应字节码指令
```java
0 ldc #4 <10.0>
2 fstore_1
3 fload_1
4 fneg
5 fstore_2
6 fload_2
7 fneg
8 fstore_1
9 return
```
> 代码 2
```java
public void method3() {
    int i = 100;
    i = i + 10;
}
```
对应字节码指令
```java
0 bipush 100
2 istore_1
3 iload_1
4 bipush 10
6 iadd
7 istore_1
8 return
```
> 代码 3
```java
public void method3() {
    int i = 100;
    i += 10;
}
```
对应字节码指令
```java
0 bipush 100
2 istore_1
3 iinc 1 by 10
6 return
```
> 代码 4
```java
public int method4() {
    int a = 80;
    int b = 7;
    int c = 10;
    return (a + b) * c;
}
```
对应字节码指令
```java
 0 bipush 80
 2 istore_1
 3 bipush 7
 5 istore_2
 6 bipush 10
 8 istore_3
 9 iload_1
10 iload_2
11 iadd
12 iload_3
13 imul
14 ireturn
```
> 代码 5
```java
public int method5(int i, int j) {
    return ((i + j - 1) & ~(j - 1));
}
```
对应字节码指令
```java
 0 iload_1
 1 iload_2
 2 iadd
 3 iconst_1
 4 isub
 5 iload_2
 6 iconst_1
 7 isub
 8 iconst_m1
 9 ixor
10 iand
11 ireturn
```
> 代码 6：++i
```java
public void method6() {
    int i = 10;
    ++i;
}
```
对应字节码指令
```java
0 bipush 10
2 istore_1
3 iinc 1 by 1
6 return
```
> 代码 7：i++
```java
public void method7() {
    int i = 10;
    i++;
}
```
对应字节码指令
```java
0 bipush 10
2 istore_1
3 iinc 1 by 1
6 return
```
- 从上述代码片段6和7可以看出，如果`i++`和`++i`不涉及到其他赋值运算，二者的字节码指令完全相同
> 代码 8：i++与++i赋值操作
```java
public void method8() {
    int i = 10;
    int a = i++;

    int j = 20;
    int b = ++j;
}
```
对应字节码指令
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 iinc 1 by 1
 7 istore_2
 8 bipush 20
10 istore_3
11 iinc 3 by 1
14 iload_3
15 istore 4
17 return
```
> 代码 9
```java
public void method9() {
    int i = 10;
    i = i++;
    System.out.println(i); // 10
}
```
对应字节码指令
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 iinc 1 by 1
 7 istore_1
 8 getstatic #2 <java/lang/System.out>
11 iload_1
12 invokevirtual #5 <java/io/PrintStream.println>
15 return
```
## 3.2 比较指令的说明
- 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈
- 比较指令有：`dcmpg`、`dcmpl`、`fcmpg`、`fcmpl`、`lcmp`
    - 与前面的指令类似：首字符`d`表示`double`类型，`f`表示`float`类型，`l`表示`long`类型
- 对于double和float类型的数字，由于`NaN`的存在，各有两个版本的比较指令。以float为例， 有fcmpg和fcmpl两个指令，它们的区别在于数字比较时，若遇到NaN值，处理结果不同
- 指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述
- 指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令
> 举例
- 指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做出比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1，若v1=v2，则压入0；若v1>v2，则压入1；若v1<v2则压入-1
- 两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1，而fcmpl会压入-1

# 4. 类型转换指令
- 类型转换指令可以将两种不同的**数值类型（除了布尔类型之外）**进行相互转换
- 这些转换操作一般用于实现用户代码中的**显式类型转换操作**，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题
## 4.1 宽化类型转换(widening numeric conversion)
### 4.1.1 转换规则
Java虚拟机直接支持以下数值的宽化类型转换（小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：
- 从int类型到long、float或者double类型。对应的指令时：`i2l`、`i2f`、`i2d`
- 从long类型到float、double类型。对应的指令是：`l2f`、`l2d`
- 从float类型到double类型。对应的指令是：`f2d`
> 代码测试 1
```java
public void upCast1() {
    int i = 10;
    long l = i;
    float f = i;
    double d = i;

    float f1 = l;
    double d1 = l;
    double d2 = f1;
}
```
对应字节码指令
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 i2l
 5 lstore_2
 6 iload_1
 7 i2f
 8 fstore 4
10 iload_1
11 i2d
12 dstore 5
14 lload_2
15 l2f
16 fstore 7
18 lload_2
19 l2d
20 dstore 8
22 fload 7
24 f2d
25 dstore 10
27 return
```
### 4.1.2 精度损失问题
- 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如从int转换到long，或者从int转换到double，都不会丢失任何信息，转换前后的值是精确相等的
- 从int、long类型数值转换到float，或者long类型数值转换到double时，将可能发生精度丢失：可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近舍入模式所得到的的正确整数值
- 尽管宽化类型转换实际上是最可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常

### 4.1.3 补充说明
从byte、char和short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转换为int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将byte转为long时，使用的是`i2l`，可以看到在内部byte这里已经等同于int类型处理，类似的还有short类型。这种处理方式有两个特点：
- 可以减少实际的数据类型，如果short和byte都准备一套指令，那么指令的数量就会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中
- 由于局部变量表中槽位固定位32位，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型
> 代码测试 1
```java
public void upCast3(byte b) {
    int i = b;
    long l = b;
    double d = b;
}
```
对应字节码指令：
```java
0 iload_1
1 istore_2
2 iload_1
3 i2l
4 lstore_3
5 iload_1
6 i2d
7 dstore 5
9 return
```
> 代码测试 2
```java
public void upCast4(short s) {
    int i = s;
    long l = s;
    float f = s;
}
```
对应字节码指令
```java
0 iload_1
1 istore_2
2 iload_1
3 i2l
4 lstore_3
5 iload_1
6 i2f
7 fstore 5
9 return
```
## 4.2 窄化类型转换 (Narrowing Numeric Conversion)
### 4.2.1 转换规则
Java虚拟机也直接支持以下窄化类型转换
- 从int类型转化为byte、short或者char类型，对应指令有：`i2b`、`i2s`、`i2c`
- 从long类型到int类型，对应指令有：`l2i`
- 从float类型到int或者long类型，对应指令有：`f2i`、`f2l`
- 从double类型到int、long或者float类型，对应指令有：`d2i`、`d2l`、`d2f`
> 代码测试 1
```java
public void downCast1() {
    int i = 10;
    byte b = (byte) i;
    short s = (short) i;
    char c = (char) i;

    long l = 10L;
    int i1 = (int) l;
    byte b1 = (byte) l;
}
```
对应字节码指令：
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 i2b
 5 istore_2
 6 iload_1
 7 i2s
 8 istore_3
 9 iload_1
10 i2c
11 istore 4
13 ldc2_w #11 <10>
16 lstore 5
18 lload 5
20 l2i
21 istore 7
23 lload 5
25 l2i
26 i2b
27 istore 8
29 return
```
可以看到，由于没有float转换到byte的指令，所以在转换过程中做了两次转换：
```java
25 l2i
26 i2b
```
> 代码测试 2
```java
public void downCast2() {
    short s = 10;
    byte b = (byte) s;

    byte b1 = 20;
    short s1 = (byte) b1;
}
```

对应字节码指令：
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 i2b
 5 istore_2
 6 bipush 20
 8 istore_3
 9 iload_3
10 i2s
11 istore 4
13 return
```
可见short转换为byte直接为`i2b`，byte转换为short为`i2s`
### 4.2.2 精度损失问题
- 窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此转换过程很可能导致数值丢失精度
- 尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常
> 代码测试
```java
public void downCast3() {
    int i = 128;
    byte b = (byte) i;
    System.out.println(b);  // -128
}
```

### 4.2.3 补充说明
- 当一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：
    - 当浮点值是NaN，那转换结果就是int或long类型的0
    - 当浮点值不是无穷大的话，浮点值使用IEEE754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围内，那转换结果就是v；否则，将根据v的符号，转换为T所能表示的最大或者最小正数
- 当将一个double类型窄化转换为float类型时，将遵循以下转换规则：通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：
    - 如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零
    - 如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大
    - 对于double类型的NaN值将按规定转换为float类型的NaN值
> 代码测试
```java
public void downCast4() {
    double d1 = Double.NaN;
    int i = (int) d1;
    System.out.println(i);  // 0
    float f1 = (float) d1;
    System.out.println(f1); // NaN

    double d2 = Double.POSITIVE_INFINITY;
    long l = (long) d2;
    int j = (int) d2;
    float f = (float) d2;

    System.out.println(l);  // 9223372036854775807
    System.out.println(Long.MAX_VALUE); // 9223372036854775807
    System.out.println(j);  // 2147483647
    System.out.println(Integer.MAX_VALUE);  // 2147483647
    System.out.println(f);  // Infinity
    
}
```
# 5. 对象的创建与访问指令
Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为**创建指令、字段访问指令、数组操作指令和类型检查指令**
## 5.1 创建指令
虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令
- 创建类实例的指令：`new`
    - 它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入操作数栈
- 创建数组的指令：`newarray`、`anewarray`、`multianewarray`
    - `newarray`：创建基本类型数组
    - `anewarray`：创建引用类型数组
    - `multianewarray`：创建多维数组
> 代码测试 1
```java
public void newInstance() {
    Object obj = new Object();
    File file = new File("1.txt");
}
```
对应字节码指令：
```java
 0 new #2 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 new #3 <java/io/File>
11 dup
12 ldc #4 <1.txt>
14 invokespecial #5 <java/io/File.<init>>
17 astore_2
18 return
```
> 代码测试 2
```java
public void newArray() {
    int[] intArray = new int[10];
    Object[] objArray = new Object[10];
    int[][] mintArray = new int[10][10];
    String[][] strArray = new String[10][];
}
```
对应字节码指令：
```java
 0 bipush 10
 2 newarray 10 (int)
 4 astore_1
 5 bipush 10
 7 anewarray #2 <java/lang/Object>
10 astore_2
11 bipush 10
13 bipush 10
15 multianewarray #6 <[[I> dim 2
19 astore_3
20 bipush 10
22 anewarray #7 <[Ljava/lang/String;>
25 astore 4
27 return
```
## 5.2 字段访问指令
对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素
- 访问类字段（static字段，或者称为类变量）的指令：`getstatic`、`putstatic`
- 访问类舍利子段（非static字段，或称为实例变量）的指令：`getfield`、`putfield`

以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈
> 代码测试 1
```java
public void sayHello() {
    System.out.println("hello");
}
```
对应字节码指令：
```java
0 getstatic #8 <java/lang/System.out>
3 ldc #9 <hello>
5 invokevirtual #10 <java/io/PrintStream.println>
8 return
```
> 代码测试 2
```java
public void setOrderId() {
    Order order =  new Order();
    order.id = 1001;
    System.out.println(order.id);

    Order.name = "ORDER";
    System.out.println(Order.name);
}

class Order {
    int id;
    static String name;
}
```
对应字节码指令
```java
 0 new #11 <com/nasuf/jdk8/Order>
 3 dup
 4 invokespecial #12 <com/nasuf/jdk8/Order.<init>>
 7 astore_1
 8 aload_1
 9 sipush 1001
12 putfield #13 <com/nasuf/jdk8/Order.id>
15 getstatic #8 <java/lang/System.out>
18 aload_1
19 getfield #13 <com/nasuf/jdk8/Order.id>
22 invokevirtual #14 <java/io/PrintStream.println>
25 ldc #15 <ORDER>
27 putstatic #16 <com/nasuf/jdk8/Order.name>
30 getstatic #8 <java/lang/System.out>
33 getstatic #16 <com/nasuf/jdk8/Order.name>
36 invokevirtual #10 <java/io/PrintStream.println>
39 return
```
## 5.3 数组操作指令
数组操作指令主要有：`xastore`和`xaload`指令，具体为：
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
- 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore （要注意，因为数组是对象，真实的值存放在堆空间，此处的store指的是修改堆空间中的值，而非局部变量表）
即：

| 数组类型       | 加载指令 | 存储指令 |
| -------------- | -------- | -------- |
| byte / boolean | baload   | bastore  |
| char           | caload   | castore  |
| short          | saload   | sastore  |
| int            | iaload   | iastore  |
| long           | laload   | lastore  |
| float          | faload   | fastore  |
| double         | daload   | dastore  |
| reference      | aaload   | aastore  |
- 取数组长度的指令：arraylength，该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈
> 说明
- 指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数栈中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入堆栈
- xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈定需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置
> 代码测试 1
```java
public void setArray() {
    int[] intArray = new int[10];
    intArray[3] = 20;
    System.out.println(intArray[1]);
}
```
对应字节码指令：
```java
 0 bipush 10
 2 newarray 10 (int)
 4 astore_1
 5 aload_1
 6 iconst_3
 7 bipush 20
 9 iastore
10 getstatic #8 <java/lang/System.out>
13 aload_1
14 iconst_1
15 iaload
16 invokevirtual #14 <java/io/PrintStream.println>
19 return
```
> 代码测试 2
```java
public void arrLength() {
    double[] arr = new double[10];
    System.out.println(arr.length);
}
```
对应字节码指令：
```java
 0 bipush 10
 2 newarray 7 (double)
 4 astore_1
 5 getstatic #8 <java/lang/System.out>
 8 aload_1
 9 arraylength
10 invokevirtual #14 <java/io/PrintStream.println>
13 return
```

## 5.4 类型检查指令
检查类实例或数组类型的指令：`instanceof`、`checkcast`
- 指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出`ClassCastException`异常
- 指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈
> 代码测试
```java
public String checkCast(Object obj) {
    if (obj instanceof String) {
        return (String) obj;
    } else {
        return null;
    }
}
```
对应字节码指令：
```java
 0 aload_1
 1 instanceof #17 <java/lang/String>
 4 ifeq 12 (+8)
 7 aload_1
 8 checkcast #17 <java/lang/String>
11 areturn
12 aconst_null
13 areturn
```
# 6. 方法调用与返回指令
## 6.1 方法调用指令
方法调用指令包括：`invokevirtual`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokedynamic`
- `invokevirtual`指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式
- `invokeinterface`指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用
- `invokespecial`指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发
- `invokestatic`指令用于调用命名类中的类方法（static方法）。这是静态绑定的
- `invokedynmaic`指令调用动态绑定的方法，这是JDK1.7后新加入的指令，用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法
    - 前面四条调用指令的分派逻辑都固化在Java虚拟机内部，而`invokedynamic`指令的分派逻辑是由用于所设定的引导方法决定的
> 代码测试 1
```java
public void invoke1() {
    // 类实例构造器方法<init>()
    Date date = new Date();
    Thread t1 = new Thread();
    // 父类方法
    super.toString();
    // 私有方法
    methodPrivate();
}

private void methodPrivate() { }
```
对应invoke1方法字节码指令：
```java
 0 new #2 <java/util/Date>
 3 dup
 4 invokespecial #3 <java/util/Date.<init>>
 7 astore_1
 8 new #4 <java/lang/Thread>
11 dup
12 invokespecial #5 <java/lang/Thread.<init>>
15 astore_2
16 aload_0
17 invokespecial #6 <java/lang/Object.toString>
20 pop
21 aload_0
22 invokespecial #7 <com/nasuf/jdk8/MethodInvokeReturnTest.methodPrivate>
25 return
```
假如`methodPrivate()`方法变为public，则对应字节码变为：
```java
22 invokevirtual #7 <com/nasuf/jdk8/MethodInvokeReturnTest.methodPrivate>
```
> 代码测试 2
```java
public void invoke2() {
    methodStatic();
}

public static void methodStatic() { }
```
对应invoke2方法字节码指令：
```java
0 invokestatic #8 <com/nasuf/jdk8/MethodInvokeReturnTest.methodStatic>
3 return
```
假如`methodStatic()`方法变为private static，则对应字节码依然为：
```java
0 invokestatic #8 <com/nasuf/jdk8/MethodInvokeReturnTest.methodStatic>
```
> 代码测试 3
```
public void invoke3() {
    Thread t1 = new Thread();
    ((Runnable) t1).run();

    Comparable<Integer> com = null;
    com.compareTo(123);
}
```
对应字节码指令：
```java
 0 new #4 <java/lang/Thread>
 3 dup
 4 invokespecial #5 <java/lang/Thread.<init>>
 7 astore_1
 8 aload_1
 9 invokeinterface #9 <java/lang/Runnable.run> count 1
14 aconst_null
15 astore_2
16 aload_2
17 bipush 123
19 invokestatic #10 <java/lang/Integer.valueOf>
22 invokeinterface #11 <java/lang/Comparable.compareTo> count 2
27 pop
28 return
```
> 代码测试 4
```java
public void invoke4() {
    System.out.println("hello");
    Thread t1 = null;
    t1.run();
}
```
对应字节码指令：
```java
 0 getstatic #12 <java/lang/System.out>
 3 ldc #13 <hello>
 5 invokevirtual #14 <java/io/PrintStream.println>
 8 aconst_null
 9 astore_1
10 aload_1
11 invokevirtual #15 <java/lang/Thread.run>
14 return
```
> 代码测试 5
```java
public class InterfaceMethodTest {
    public static void main(String[] args) {
        AA aa = new BB();
        aa.method2();
        AA.method1();
    }
}

interface AA {
    public static void method1() { }

    public default void method2() { }
}

class BB implements AA { }
```
对应字节码指令：
```java
 0 new #2 <com/nasuf/jdk8/BB>
 3 dup
 4 invokespecial #3 <com/nasuf/jdk8/BB.<init>>
 7 astore_1
 8 aload_1
 9 invokeinterface #4 <com/nasuf/jdk8/AA.method2> count 1
14 invokestatic #5 <com/nasuf/jdk8/AA.method1>
17 return
```

## 6.2 方法返回指令
方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的
- 包括`ireturn`（当返回值是boolean、byte、char、short和int类型时使用）、`lreturn`、`freturn`、`dreturn`和`areturn`
- 另外还有一种`return`指令供声明为void的方法、实例初始化方法以及类和接口的初始化方法使用

| 返回类型                         | 返回指令 |
| -------------------------------- | -------- |
| void                             | return   |
| int (boolean、byte、char、short) | ireturn  |
| long                             | lreturn  |
| float                            | freturn  |
| double                           | dreturn  |
| reference                        | areturn  |

- 通过`ireturn`指令，将当前函数操作数栈的栈顶元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。如果当前返回的是`synchronized`方法，那么还会执行一个隐含的`monitorexit`指令，退出临界区。最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者

> 代码测试 1
```java
public int returnInt() {
    int i = 500;
    return i;
}
```
对应字节码指令
```java
0 sipush 500
3 istore_1
4 iload_1
5 ireturn
```
> 代码测试 2
```java
public double returnDouble() {
    return 0.0;
}
```
对应字节码指令
```java
0 dconst_0
1 dreturn
```
> 代码测试 3
```java
public String returnString() {
    return "hello, world";
}
```
对应字节码指令
```java
0 ldc #16 <hello, world>
2 areturn
```
> 代码测试 4
```java
public int[] returnArr() {
    return null;
}
```
对应字节码指令
```java
0 aconst_null
1 areturn
```
> 代码测试 5
```java
public float returnFloat() {
    int i = 10;
    return i;
}
```
对应字节码指令
```java
0 bipush 10
2 istore_1
3 iload_1
4 i2f
5 freturn
```
> 代码测试 6
```java
public byte returnByte() {
    return 0;
}
```
对应字节码指令
```java
0 iconst_0
1 ireturn
```
# 7. 操作数栈管理指令
如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈。这类指令包括：
- 将一个或两个元素从栈顶弹出，并直接放弃：`pop`、`pop2`
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：`dup`、`dup2`、`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`
- 将栈最顶端的两个slot数值位置交换：`swap`；Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令
- 指令`nop`是一个非常特殊的指令，它的字节码为`0x00`，和汇编语言中的`nop`一样，它表示什么都不做。这条指令一般可用于调试、占位等
这些指令属于通用型，对栈的压入或者弹出无需指明数据类型
> 说明
- 不带`_x`的指令是复制栈顶数据并压入栈顶，包括两个指令：`dup`和`dup2`，dup的系数代表要复制的slot个数
    - `dup`开头的指令用于复制1个slot的数据，例如1个int或者1个reference类型的数据
    - `dup2`开头的指令用于复制2个slot的数据，例如1个long，或2个int，或1个int+1个float类型的数据
- 带`_x`的指令是复制栈顶数据并插入栈顶一下的某个位置，共有4个指令：`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`；对于带`_x`的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置，因此：
    - `dup_x1`插入位置：1+1=2，即栈顶2个slot下面
    - `dup_x2`插入位置：1+2-3，即栈顶3个slot下面
    - `dup2_x1`插入位置：2+1=3，即栈顶3个slot下面
    - `dup2_x2`插入位置：2+2=4，即栈顶4个slot下面
- `pop`：将栈顶的1个slot数值出栈，例如1个short类型数值
- `pop2`：将栈顶的2个slot数值出栈，例如1个double类型数值，或者2个int类型数值
> 代码测试 1
```java
public void print() {
    Object obj = new Object();
    String info = obj.toString();
}
```
对应字节码指令：
```java
 0 new #2 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 aload_1
 9 invokevirtual #3 <java/lang/Object.toString>
12 astore_2
13 return
```
> 代码测试 2
```java
public void print() {
    Object obj = new Object();
    obj.toString();
}
```
对应字节码指令：
```java
 0 new #2 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 aload_1
 9 invokevirtual #3 <java/lang/Object.toString>
12 pop
13 return
```
> 代码测试 3
```java
public void foo() {
    bar();
}

public long bar() {
    return 0;
}
```
foo()方法对应字节码指令：
```java
0 aload_0
1 invokevirtual #4 <com/nasuf/jdk8/StackOperateTest.bar>
4 pop2
5 return
```
> 代码测试 4
```java
public long nextIndex() {
    return index++;
}

 private long index = 0;
```
对应字节码指令：
```java
 0 aload_0
 1 dup
 2 getfield #2 <com/nasuf/jdk8/StackOperateTest.index>
 5 dup2_x1
 6 lconst_1
 7 ladd
 8 putfield #2 <com/nasuf/jdk8/StackOperateTest.index>
11 lreturn
```
# 8. 控制转移指令
程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量的字节码指令，大体上可以分为：**比较指令、条件跳转指令、比较条件跳转指令、多条件分支跳转指令、无条件跳转指令**等
## 8.1 条件跳转指令
- 条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。
- 条件跳转指令有：`ifeq`、`iflt`、`ifle`、`ifgt`、`ifge`、`ifnull`、`ifnonnull`，这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）
- 它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到指定位置

> 具体说明

| 指令      | 说明                             |
| --------- | -------------------------------- |
| ifeq      | 当栈顶int类型数值等于0时跳转     |
| ifne      | 当栈顶int类型数值不等于0时跳转   |
| iflt      | 当栈顶int类型数值小于0时跳转     |
| ifle      | 当栈顶int类型数值小于等于0时跳转 |
| ifgt      | 当栈顶int类型数值大于0时跳转     |
| ifge      | 当栈顶int类型数值大于等于0时跳转 |
| ifnull    | 为null时跳转                     |
| ifnonnull | 不为null时跳转                   |

> 注意
- 与前面运算规则一致：
    - 对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成
    - 对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（见上文），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转
- 由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的

> 代码测试 1
```java
public void compare1() {
    int a = 0;
    if (a == 0) {
        a = 10;
    } else {
        a = 20;
    }
}
```
对应字节码指令：
```java
 0 iconst_0
 1 istore_1
 2 iload_1
 3 ifne 12 (+9)
 6 bipush 10
 8 istore_1
 9 goto 15 (+6)
12 bipush 20
14 istore_1
15 return
```

> 代码测试 2
```java
public boolean compareNull(String str) {
    if (str == null) {
        return true;
    } else {
        return false;
    }
}
```
对应字节码指令：
```java
0 aload_1
1 ifnonnull 6 (+5)
4 iconst_1
5 ireturn
6 iconst_0
7 ireturn
```

> 代码测试 3
```java
public void compare2() {
    float f1 = 9;
    float f2 = 10;
    System.out.println(f1 < f2);
}
```
对应字节码指令：
```java
 0 ldc #2 <9.0>
 2 fstore_1
 3 ldc #3 <10.0>
 5 fstore_2
 6 getstatic #4 <java/lang/System.out>
 9 fload_1
10 fload_2
11 fcmpg
12 ifge 19 (+7)
15 iconst_1
16 goto 20 (+4)
19 iconst_0
20 invokevirtual #5 <java/io/PrintStream.println>
23 return
```
> 代码测试 4
```java
public void compare3() {
    int i1 = 10;
    long l1 = 20;
    System.out.println(i1 < l1);
}
```
对应字节码指令：
```java
 0 bipush 10
 2 istore_1
 3 ldc2_w #6 <20>
 6 lstore_2
 7 getstatic #4 <java/lang/System.out>
10 iload_1
11 i2l
12 lload_2
13 lcmp
14 ifge 21 (+7)
17 iconst_1
18 goto 22 (+4)
21 iconst_0
22 invokevirtual #5 <java/io/PrintStream.println>
25 return
```

> 代码测试 5
```java
public int compare4(double d) {
    if (d > 50.0) {
        return 1;
    } else {
        return -1;
    }
}
```
对应字节码指令：
```java
 0 dload_1
 1 ldc2_w #8 <50.0>
 4 dcmpl
 5 ifle 10 (+5)
 8 iconst_1
 9 ireturn
10 iconst_m1
11 ireturn
```
## 8.2 比较条件跳转指令
- 比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一
- 这类指令有：`if_icmpeq`、`if_icmpne`、`if_icmplt`、`if_icmpgt`、`if_icmple`、`if_icmpge`、`if_acmpeq`和`if_acmpne`。其中指令助记符加上`if_`后，以字符`i`开头的指令针对int类型整数操作（也包括short和byte类型），以字符`a`开头的指令表示对象引用的比较
> 具体说明

| 指令      | 描述                                                |
| --------- | --------------------------------------------------- |
| if_icmpeq | 比较栈顶两int类型数值大小，当前者等于后者时跳转     |
| if_icmpne | 比较栈顶两int类型数值大小，当前者不等于后者时跳转   |
| if_icmplt | 比较栈顶两int类型数值大小，当前者小于后者时跳转     |
| if_icmple | 比较栈顶两int类型数值大小，当前者小于等于后者时跳转 |
| if_icmpgt | 比较栈顶两int类型数值大小，当前者大于后者时跳转     |
| if_icmpge | 比较栈顶两int类型数值大小，当前者大于等于后者时跳转 |
| if_acmpeq | 比较栈顶两引用类型数值，当结果相等时跳转            |
| if_acmpne | 比较栈顶两引用类型数值，当结果不相等时跳转          |

- 这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。**指令执行完成后，栈顶的两个元素都被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句**

> 代码测试 1
```java
public void ifCompare1() {
    int i = 10;
    int j = 20;
    System.out.println(i < j);
}
```
对应字节码指令：
```java
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 getstatic #4 <java/lang/System.out>
 9 iload_1
10 iload_2
11 if_icmpge 18 (+7)
14 iconst_1
15 goto 19 (+4)
18 iconst_0
19 invokevirtual #5 <java/io/PrintStream.println>
22 return
```
> 代码测试 2
```java
public void ifCompare2() {
    short s1 = 9;
    byte b1 = 10;
    System.out.println(s1 > b1);
}
```
对应字节码指令（与测试1中的字节码指令除了bipush的值外，完全相同）：
```java
 0 bipush 9
 2 istore_1
 3 bipush 10
 5 istore_2
 6 getstatic #4 <java/lang/System.out>
 9 iload_1
10 iload_2
11 if_icmple 18 (+7)
14 iconst_1
15 goto 19 (+4)
18 iconst_0
19 invokevirtual #5 <java/io/PrintStream.println>
22 return
```
> 代码测试 3
```java
public void ifCompare3() {
    Object obj1 = new Object();
    Object obj2 = new Object();
    System.out.println(obj1 == obj2);
    System.out.println(obj1 != obj2);
}
```
对应字节码指令：
```java
 0 new #10 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 new #10 <java/lang/Object>
11 dup
12 invokespecial #1 <java/lang/Object.<init>>
15 astore_2
16 getstatic #4 <java/lang/System.out>
19 aload_1
20 aload_2
21 if_acmpne 28 (+7)
24 iconst_1
25 goto 29 (+4)
28 iconst_0
29 invokevirtual #5 <java/io/PrintStream.println>
32 getstatic #4 <java/lang/System.out>
35 aload_1
36 aload_2
37 if_acmpeq 44 (+7)
40 iconst_1
41 goto 45 (+4)
44 iconst_0
45 invokevirtual #5 <java/io/PrintStream.println>
48 return
```
## 8.3 多条件分支跳转指令
多条件分支跳转指令是专为`switch-case`语句设计的，主要有`tableswitch`和`lookupswitch`
| 指令         | 描述                             |
| ------------ | -------------------------------- |
| tableswitch  | 用于switch条件跳转，case值连续   |
| lookupswitch | 用于switch条件跳转，case值不连续 |

从助记符上看，两者都是switch语句的实现，区别是：
- `tableswitch`要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量的位置，因此效率比较高
- `lookupswitch`内部存放着多个离散的`case-offset`对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低

由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset

**指令lookupswitch处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序**，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default

> 代码测试 1
```java
public void switchTest1(int select) {
    int num;
    switch (select) {
        case 1:
            num = 10;
            break;
        case 2:
            num = 20;
            break;
        case 3:
            num = 30;
            break;
        default:
            num = 40;
    }
}
```
对应字节码指令：
```java
 0 iload_1
 1 tableswitch 1 to 3	1:  28 (+27)
	2:  34 (+33)
	3:  40 (+39)
	default:  46 (+45)
28 bipush 10
30 istore_2
31 goto 49 (+18)
34 bipush 20
36 istore_2
37 goto 49 (+12)
40 bipush 30
42 istore_2
43 goto 49 (+6)
46 bipush 40
48 istore_2
49 return
```
如果将`case 2`语句中的`break;`注释掉，对应字节码指令如下：
```java
 0 iload_1
 1 tableswitch 1 to 3	1:  28 (+27)
	2:  34 (+33)
	3:  37 (+36)
	default:  43 (+42)
28 bipush 10
30 istore_2
31 goto 46 (+15)
34 bipush 20
36 istore_2
37 bipush 30
39 istore_2
40 goto 46 (+6)
43 bipush 40
45 istore_2
46 return
```
> 代码测试 2
```java
public void switchTest2(int select) {
    int num;
    switch (select) {
        case 100:
            num = 10;
            break;
        case 500:
            num = 20;
            break;
        case 200:
            num = 30;
            break;
        default:
            num = 40;
    }
}
```
对应字节码指令：
```java
 0 iload_1
 1 lookupswitch 3
	100:  36 (+35)
	200:  48 (+47)
	500:  42 (+41)
	default:  54 (+53)
36 bipush 10
38 istore_2
39 goto 57 (+18)
42 bipush 20
44 istore_2
45 goto 57 (+12)
48 bipush 30
50 istore_2
51 goto 57 (+6)
54 bipush 40
56 istore_2
57 return
```
**应注意：在代码中case语句的值并非顺序排列，但是在生成的字节码指令中，是严格按照顺序从小到大排列**
> 代码测试 3
```java
// JDK7 新特性：引入string类型作为switch的key
public void switchTest3(String season) {
    switch (season) {
        case "SPRING": break;
        case "SUMMER": break;
        case "AUTUMN": break;
        case "WINTER": break;
    }
}
```
对应字节码指令：
```java
  0 aload_1
  1 astore_2
  2 iconst_m1
  3 istore_3
  4 aload_2
  5 invokevirtual #11 <java/lang/String.hashCode>
  8 lookupswitch 4
	-1842350579:  52 (+44)
	-1837878353:  66 (+58)
	-1734407483:  94 (+86)
	1941980694:  80 (+72)
	default:  105 (+97)
 52 aload_2
 53 ldc #12 <SPRING>
 55 invokevirtual #13 <java/lang/String.equals>
 58 ifeq 105 (+47)
 61 iconst_0
 62 istore_3
 63 goto 105 (+42)
 66 aload_2
 67 ldc #14 <SUMMER>
 69 invokevirtual #13 <java/lang/String.equals>
 72 ifeq 105 (+33)
 75 iconst_1
 76 istore_3
 77 goto 105 (+28)
 80 aload_2
 81 ldc #15 <AUTUMN>
 83 invokevirtual #13 <java/lang/String.equals>
 86 ifeq 105 (+19)
 89 iconst_2
 90 istore_3
 91 goto 105 (+14)
 94 aload_2
 95 ldc #16 <WINTER>
 97 invokevirtual #13 <java/lang/String.equals>
100 ifeq 105 (+5)
103 iconst_3
104 istore_3
105 iload_3
106 tableswitch 0 to 3	0:  136 (+30)
	1:  139 (+33)
	2:  142 (+36)
	3:  145 (+39)
	default:  145 (+39)
136 goto 145 (+9)
139 goto 145 (+6)
142 goto 145 (+3)
145 return
```
## 8.4 无条件跳转指令
目前主要的无条件跳转指令为`goto`，该指令接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处

如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令`goto_w`，它和`goto`有相同的作用，但是接收4个字节的操作数，可以表示更大的地址范围

指令`jsr`、`jsr_w`、`ret`虽然也是无条件跳转的，但主要用于`try-finally`语句，且已经被虚拟机逐渐废弃

| 指令   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| goto   | 无条件跳转                                                   |
| goto_w | 无条件跳转（宽索引）                                         |
| jsr    | 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶      |
| jsr_w  | 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶    |
| ret    | 返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用） |

> 代码测试 1
```java
public void whileInt() {
    int i = 0;
    while ( i < 100 ) {
        String s = "nasuf";
        i++;
    }
}
```
对应字节码指令：
```java
 0 iconst_0
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpge 17 (+12)
 8 ldc #17 <nasuf>
10 astore_2
11 iinc 1 by 1
14 goto 2 (-12)
17 return
```
> 代码测试 2
```java
public void whileDouble() {
    double d = 0.0;
    while ( d < 100.1 ) {
        String s = "nasuf";
        d++;
    }
}
```
对应字节码指令：
```java
 0 dconst_0
 1 dstore_1
 2 dload_1
 3 ldc2_w #18 <100.1>
 6 dcmpg
 7 ifge 20 (+13)
10 ldc #17 <nasuf>
12 astore_3
13 dload_1
14 dconst_1
15 dadd
16 dstore_1
17 goto 2 (-15)
20 return
```
> 代码测试 3
```java
public void printFor() {
    short i;
    for (i = 0; i < 100; i++) {
        String s = "nasuf";
    }
}
```
对应字节码指令：
```java
 0 iconst_0
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpge 19 (+14)
 8 ldc #17 <nasuf>
10 astore_2
11 iload_1
12 iconst_1
13 iadd
14 i2s
15 istore_1
16 goto 2 (-14)
19 return
```
思考上述代码测试2和3，其实二者对于while和for循环处理的字节码是完全一样的
> 代码测试 4
```java
public void doWhileTest() {
    int i = 1;
    do {
        i++;
    } while (i <= 100);
}
```
对应字节码指令：
```java
 0 iconst_1
 1 istore_1
 2 iinc 1 by 1
 5 iload_1
 6 bipush 100
 8 if_icmple 2 (-6)
11 return
```

# 9. 异常处理指令
## 9.1 抛出异常指令
在Java程序中显式抛出异常的操作（throw语句）都是由`athrow`指令来实现。除了使用throw语句显式抛出异常情况之外，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为0时，虚拟机会在`idiv`或`ldiv`指令中抛出`ArithmeticException`异常

**要注意，在正常情况下，操作数栈的压入弹出都是一条条指令完成的，唯一例外的情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上**

> 代码测试 1
```java
public void throwZero(int i) {
    if ( i == 0 ) {
        throw new RuntimeException("arg is zero.");
    }
}
```
对应字节码指令：
```java
 0 iload_1
 1 ifne 14 (+13)
 4 new #2 <java/lang/RuntimeException>
 7 dup
 8 ldc #3 <arg is zero.>
10 invokespecial #4 <java/lang/RuntimeException.<init>>
13 athrow
14 return
```
> 代码测试 2
```java
public void throwOne(int i) {
    if ( i == 1 ) {
        throw new RuntimeException("arg is one.");
    }
}
```
对应字节码指令：
```java
 0 iload_1
 1 iconst_1
 2 if_icmpne 15 (+13) // 对比测试1中的指令：ifne
 5 new #2 <java/lang/RuntimeException>
 8 dup
 9 ldc #5 <arg is one.>
11 invokespecial #4 <java/lang/RuntimeException.<init>>
14 athrow
15 return
```
> 代码测试 3
```java
public void throwOne(int i) throws RuntimeException, IOException {
    if ( i == 1 ) {
        throw new RuntimeException("arg is one.");
    }
}
```
对应字节码指令（与测试2中的指令没有任何区别）：
```java
 0 iload_1
 1 iconst_1
 2 if_icmpne 15 (+13)
 5 new #2 <java/lang/RuntimeException>
 8 dup
 9 ldc #5 <arg is one.>
11 invokespecial #4 <java/lang/RuntimeException.<init>>
14 athrow
15 return
```
但是会附加一个异常信息：

![image.png](/images/jvm/16/1.png)

对于系统已经定义好的运行时异常的抛出，不会体现在字节码指令或者异常表中，如以下测试代码：
> 代码测试 4
```java
public void throwArithmatic() {
    int i = 10;
    int j = i/0;
    System.out.println(j);
}
```
对应字节码指令：
```java
 0 bipush 10
 2 istore_1
 3 iload_1
 4 iconst_0
 5 idiv
 6 istore_2
 7 getstatic #6 <java/lang/System.out>
10 iload_2
11 invokevirtual #7 <java/io/PrintStream.println>
14 return
```
## 9.2 异常处理与异常表
在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用`jsr`、`ret`指令），而是采用异常表来完成的

如果一个方法定义了一个`try-catch`或者`try-finally`的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息，比如：
- 起始位置
- 结束位置
- 程序计数器记录的代码处理的偏移地址
- 被捕获的异常类在常量池中的索引

当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果所在的栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程

不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标

> 代码测试 1
```java
public void tryCatch() {
    try {
        File file = new File("/d/file");
        FileInputStream fis = new FileInputStream(file);
        String info = "nasuf";
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (RuntimeException e) {
        e.printStackTrace();
    }
}
```
对应字节码指令：
```java
 0 new #8 <java/io/File>
 3 dup
 4 ldc #9 </d/file>
 6 invokespecial #10 <java/io/File.<init>>
 9 astore_1
10 new #11 <java/io/FileInputStream>
13 dup
14 aload_1
15 invokespecial #12 <java/io/FileInputStream.<init>>
18 astore_2
19 ldc #13 <nasuf>
21 astore_3
22 goto 38 (+16)
25 astore_1
26 aload_1
27 invokevirtual #15 <java/io/FileNotFoundException.printStackTrace>
30 goto 38 (+8)
33 astore_1
34 aload_1
35 invokevirtual #16 <java/lang/RuntimeException.printStackTrace>
38 return
```
异常表信息：

| Nr.  | 起始PC | 结束PC | 跳转PC | 捕获类型                                  |
| ---- | ------ | ------ | ------ | ----------------------------------------- |
| 0    | 0      | 22     | 25     | cp_info #14 java/io/FileNotFoundException |
| 1    | 0      | 22     | 33     | cp_info #2 java/lang/RuntimeException     |

上述异常表信息表明，在0到22行字节码指令运行期间，如果遇到任意一种异常抛出，则分别跳转到指定索引位置：25或33来处理

> 代码测试 2
```java
public static String func() {
    String str = "hello";
    try {
        return str;
    } finally {
        str = "world";
    }
}
```
对应字节码指令：
```java
 0 ldc #17 <hello>
 2 astore_0
 3 aload_0
 4 astore_1
 5 ldc #18 <world>
 7 astore_0
 8 aload_1
 9 areturn
10 astore_2
11 ldc #18 <world>
13 astore_0
14 aload_2
15 athrow
```
异常表信息：

| Nr.  | 起始PC | 结束PC | 跳转PC | 捕获类型       |
| ---- | ------ | ------ | ------ | -------------- |
| 0    | 3      | 5      | 10     | cp_info #0 any |

可见，该方法一定会返回 "hello" 字符串

# 10. 同步控制指令
Java虚拟机支持两种同步结构：方法级同步和方法内部一段指令序列同步，这两种同步都是使用`monitor`来支持的

## 10.1 方法级的同步
方法级的同步是隐式的，即无须通过字节码指令来控制，它在实现方法调用和返回操作中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法

当调用方法是，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否设置
- 如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
- 在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁
- 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放

> 代码测试 1
```java
private int i = 0;
public synchronized void add() {
    i++;
}
```
对应字节码指令：
```java
 0 aload_0
 1 dup
 2 getfield #2 <com/nasuf/jdk8/SynchronizationTest.i>
 5 iconst_1
 6 iadd
 7 putfield #2 <com/nasuf/jdk8/SynchronizationTest.i>
10 return
```
方法描述中可以看到如下信息：

![image.png](/images/jvm/16/2.png)

如果将代码中方法的synchronized关键字去掉，重新查看方法描述信息如下（可见此时不再有同步标志）：

![image.png](/images/jvm/16/3.png)

可见同步方法代码和普通的无同步方法代码没有什么不同，没有使用`monitorenter`和`monitorexit`进行同步区控制。这是因为，对于同步方法而言，当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁。当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，`monitorenter`和`monitorexit`指令时隐式存在的，并未直接出现在字节码中

## 10.2 方法内指定指令序列的同步
同步一段指令集序列：通常是由java中的`synchronized`语句块来表示的，jvm的指令集有`monitorenter`和`monitorexit`两条指令来支持`synchronized`关键字的语义

当一个线程进入同步代码块时，它使用`monitorenter`指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入；若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入同步代码块

当线程退出同步块时，需要使用`monitorexit`声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态

指令`monitorenter`和`monitorexit`在执行时，都需要在操作数栈定压入对象，之后`monitorenter`和`moniterexit`的锁定和释放都是针对这个对象的监视器进行的

> 代码测试 1
```java
private Object obj = new Object();
public void subtract() {
    synchronized (obj) {
        i--;
    }
}
```
对应字节码指令：
```java
 0 aload_0
 1 getfield #4 <com/nasuf/jdk8/SynchronizationTest.obj>
 4 dup
 5 astore_1
 6 monitorenter
 7 aload_0
 8 dup
 9 getfield #2 <com/nasuf/jdk8/SynchronizationTest.i>
12 iconst_1
13 isub
14 putfield #2 <com/nasuf/jdk8/SynchronizationTest.i>
17 aload_1
18 monitorexit
19 goto 27 (+8)
22 astore_2
23 aload_1
24 monitorexit
25 aload_2
26 athrow
27 return
```
此段代码还包含了异常表信息：

| Nr.  | 起始PC | 结束PC | 跳转PC | 捕获类型        |
| ---- | ------ | ------ | ------ | --------------- |
| 0    | 7      | 19     | 22     | cp_info #14 any |
| 1    | 22     | 25     | 22     | cp_info #2 any  |

表示一旦出现任何异常，一定要将监视器计数器修改为0。编译器必须确保无论方法通过何种方式完成，方法中调用过的每条`monitorenter`指令都必须执行其对应的`monitorexit`指令，而无论这个方法是正常结束还是异常结束

为了保证在方法异常完成时`monitorenter`和`monitorexit`指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器生命可处理的所有异常，它的目的就是用来执行`monitorexit`指令