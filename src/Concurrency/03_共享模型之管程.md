# 3. 共享模型之管程

## 3.1 共享带来的问题

> Java的体现

示例代码：

```java
@Slf4j(topic = "c.Test9")
public class Test9 {
    static int counter = 0;
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("counter: {}", counter);
    }
}
```

输出：

```java
18:52:10.045 [main] c.Test9 - counter: -289
```

> 问题分析

以上的结果可能是正数、负数或者零。因为Java中对静态变量的自增、自减并不是原子操作。要彻底理解必须从字节码开始分析。

例如对于`i++`操作而言（i为静态变量），实际会产生如下的jvm字节码指令：

```java
getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
iadd        // 自增
putstatic i // 将修改后的值存入静态变量i
```

而对应`i--`操作，也是类似：

```java
getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
isub        // 自减
putstatic   // 将修改后的值存入静态变量i
```

而java的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![image-20240128下午70017827](/images/concurrency/1/8.png)

如果是单线程，以上8行代码是按顺序执行（不会交错），便没有问题：

<img src="/images/concurrency/1/9.png" alt="image-20240128下午70847219" style="zoom:50%;" />

但如果是多线程，这8行代码可能出现交错运行。

出现负数的情况：

<img src="/images/concurrency/1/10.png" alt="image-20240128下午71006667" style="zoom:50%;" />

出现正数的情况：

<img src="/images/concurrency/1/11.png" alt="image-20240128下午71112804" style="zoom:50%;" />

> 临界区 Critical Section

- 一个程序运行多个线程本身是没有问题的

- 问题出现在多个线程访问共享资源

  - 多个线程读取共享资源其实也没有问题
  - 在多个线程对共享资源读写操作发生指令交错，就会出现问题

- 一段代码块内如果存在对共享资源的多线程读写操作，称这块代码为临界区，例如：

  ```java
  static int counter = 0;
  
  static void increment()
  // 临界区
  {
    counter++;
  }
  
  static void decrement()
  // 临界区
  {
    counter--;
  }
  ```

> 竞态条件 Race Condition

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

## 3.2 synchronized 解决方案

为了避免临界区的竞态条件发生，有多钟手段可以达到目的。

- 阻塞式解决方案：synchronize, Lock
- 非阻塞式解决方案：原子变量

本章节使用阻塞式解决方案synchronized，来解决上述问题，即俗称的“锁对象”。它采用互斥的方式让同一时刻至多只有一个线程能持有“锁对象”，其他线程再想获取这个锁对象时就会阻塞住。这样就能保证有锁的线程可以安全地执行临界区内的代码，不用担心线程上线文切换

注意，虽然java中互斥和同步都可以采用synchronized关键字来完成，但他们还是有区别的：

- 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
- 同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点

### 3.2.1 synchronized

语法：

```java
synchronized(对象) {
  // 临界区
}
```

示例代码：

```java
@Slf4j(topic = "c.Test9")
public class Test9 {
    static int counter = 0;
    static final Object room = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (room) {
                    counter++;
                }
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (room) {
                    counter--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("counter: {}", counter);
    }
}
```

输出永远为：

```java
19:23:19.116 [main] c.Test9 - counter: 0
```

如何理解`synchronized`的作用？

- `synchronized(对象)`中的对象，可以想象为一个房间，有唯一的入口，房间只能一次进入一人进行计算。线程`t1`和`t2`想象成两个人
- 当线程`t1`执行到`synchronized(room)`时就好比`t1`进入到了这个房间，并锁住了门，拿走了钥匙，在门内执行`i++`代码
- 这时候如果`t2`也运行到了`synchronized(room)`时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了
- 这中间即使`t1`的cpu时间片不幸用完了，被踢出了门外（不要错误地理解为锁住了对象就能一直执行下去），这时门还是锁住的，`t1`仍然拿着钥匙，`t2`线程还在阻塞状态进不来，只有下次轮到`t1`自己再次获得时间片时才能开门进入
- 当`t1`执行完`synchronized{...}`块内的代码，这时候才会从房间出来，并解开锁，唤醒`t2`线程把钥匙给他。`t2`线程这时才能进入房间，锁住门拿上钥匙，执行它的`count--`代码

总结一下，`synchronized`实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。

为了加深理解，思考如下问题：

- 如果把`synchronized(obj)`放在`for`循环外面，如何理解？
  - 这样其实是把整个`for`循环作为一个整体来进行加锁
- 如果`t1 synchronized(obj_1)`，而`t2 synchronzied(obj_2)`会怎样运行？
  - 相当于两个线程进入了不同的房间，无法保证线程安全
- 如果`t1 synchronized(obj)` 而`t2`没有加锁，如何运行？
  - `t2`线程在想访问共享资源时候，无需尝试获取锁，所以依然存在线程安全问题

### 3.2.2 案例：计数（面向对象设计）

```java
@Slf4j(topic = "c.Test9")
public class Test9 {

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.increment();
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("counter: {}", room.getCounter());
    }
}

class Room {
    private int counter = 0;

    public void increment() {
        synchronized (this) {
            counter++;
        }
    }

    public void decrement() {
        synchronized (this) {
            counter--;
        }
    }

    public int getCounter() {
        synchronized (this) {
            return counter;
        }
    }
}
```

## 3.3 方法上的synchronized

语法：

```java
class Test {
  public synchronized void test() {
    
  }
}

// 等价于：
class Test {
  public void test() {
    synchronized(this) {
      
    }
  }
}
```

```java
class Test {
  public synchronized static void test() {
    
  }
}

// 等价于：
class Test {
  public static void test() {
    synchronized(Test.class) {
      
    }
  }
}
```

所以上一节案例中的`Room` class可以修改为：

```java
class Room {
    private int counter = 0;

    public synchronized void increment() {
        counter++;
    }

    public synchronized void decrement() {
        counter--;
    }

    public synchronized int getCounter() {
        return counter;
    }
}
```

### 3.3.1 案例：“线程八锁”

> Case 1

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        new Thread(n1::a).start();
        new Thread(n1::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public synchronized void a() {
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }
}
```

说明：两个线程锁住的是同一个对象`n1`，所以输出可能是`1 -> 2`或者`2 -> 1`

> Case 2

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        new Thread(n1::a).start();
        new Thread(n1::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public synchronized void a() {
        sleep(1); // sleep 1s
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }
}
```

说明：输出可能是`(1s) -> 1 -> 2`或者`2 -> (1s) -> 1`

> Case 3

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        new Thread(n1::a).start();
        new Thread(n1::b).start();
        new Thread(n1::c).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }

    public void c() {
        log.debug("3");
    }
}
```

说明：输出可能是`3 -> (1s) -> 1 -> 2`或者`2 -> 3 -> (1s) -> 1`或者`3 -> 2 -> (1s) -> 1`

> Case 4

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        Number n2 = new Number();
        new Thread(n1::a).start();
        new Thread(n2::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }
}
```

说明：两个线程执行时候锁住的对象不相同，不存在互斥情况，所以只会有一种输出情况：`2 -> (1s) -> 1`

> Case 5

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        new Thread(Number::a).start();
        new Thread(n1::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }
}
```

说明：由于`a()`方法为`static`，加锁的对象是`Number.class`，与方法`b()`锁住的`this`对象不同，不存在互斥现象，所以只会有一种输出情况：`2 -> (1s) -> 1`

> Case 6

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        new Thread(Number::a).start();
        new Thread(Number::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public static synchronized void b() {
        log.debug("2");
    }
}
```

说明：两个方法锁住的是同一个`Number.class`对象，存在互斥现象，所以输出可能是`(1s) -> 1 -> 2`或者`2 -> (1s) -> 1`

> Case 7

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n2 = new Number();
        new Thread(Number::a).start();
        new Thread(n2::b).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public synchronized void b() {
        log.debug("2");
    }
}
```

说明：两个方法锁住的不是同一个对象，不存在互斥现象，输出只能是`2 -> (1s) -> 1`

> Case 8

```java
@Slf4j(topic = "c.TestLocks")
public class TestLocks {
    public static void main(String[] args) {
        Number n1 = new Number();
        Number n2 = new Number();
        new Thread(() -> n1.a()).start();
        new Thread(() -> n2.b()).start();
    }
}

@Slf4j(topic = "c.Number")
class Number {
    public static synchronized void a() {
        sleep(1);
        log.debug("1");
    }

    public static synchronized void b() {
        log.debug("2");
    }
}
```

说明：两个方法锁住的是同一个`Number.class`对象，所以输出可能是`(1s) -> 1 -> 2`或者`2 -> (1s) -> 1`