<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>运行时数据区（虚拟机栈和本地方法栈） - NASUF Dev Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../JVM/index.html"><strong aria-hidden="true">1.</strong> Jvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../JVM/01_概览.html"><strong aria-hidden="true">1.1.</strong> 概览</a></li><li class="chapter-item expanded "><a href="../JVM/02_类加载子系统.html"><strong aria-hidden="true">1.2.</strong> 类加载子系统</a></li><li class="chapter-item expanded "><a href="../JVM/03_运行时数据区（线程和程序计数器）.html"><strong aria-hidden="true">1.3.</strong> 运行时数据区（线程和程序计数器）</a></li><li class="chapter-item expanded "><a href="../JVM/04_本地方法接口.html"><strong aria-hidden="true">1.4.</strong> 本地方法接口</a></li><li class="chapter-item expanded "><a href="../JVM/05_运行时数据区（虚拟机栈和本地方法栈）.html" class="active"><strong aria-hidden="true">1.5.</strong> 运行时数据区（虚拟机栈和本地方法栈）</a></li></ol></li><li class="chapter-item expanded "><a href="../Rust/index.html"><strong aria-hidden="true">2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Rust/01_生命周期（基础理解）.html"><strong aria-hidden="true">2.1.</strong> 生命周期-基础理解</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NASUF Dev Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="1-虚拟机栈"><a class="header" href="#1-虚拟机栈">1. 虚拟机栈</a></h2>
<h3 id="11-虚拟机栈概述"><a class="header" href="#11-虚拟机栈概述">1.1 虚拟机栈概述</a></h3>
<h4 id="111-虚拟机栈出现的背景"><a class="header" href="#111-虚拟机栈出现的背景">1.1.1 虚拟机栈出现的背景</a></h4>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<strong>优点是跨平台，指令集小；缺点是性能下降，实现同样的功能需要更多的指令。编译器容易实现</strong>。</p>
<h4 id="122-内存中的栈与堆"><a class="header" href="#122-内存中的栈与堆">1.2.2 内存中的栈与堆</a></h4>
<p><strong>栈时运行时的单位，而堆是存储的单位</strong>。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的问题是数据存储问题，即数据怎么放，放在哪儿。</p>
<h4 id="123-虚拟机栈基本内容"><a class="header" href="#123-虚拟机栈基本内容">1.2.3 虚拟机栈基本内容</a></h4>
<ul>
<li>
<p>Java虚拟机栈是什么</p>
<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用</li>
<li>是线程私有的</li>
</ul>
</li>
<li>
<p>生命周期</p>
<ul>
<li>生命周期和线程一致</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>主管Java程序的运行，它保存方法的局部变量（<strong>8种基本数据类型， 对象的引用地址</strong>），部分结果，并参与方法的调用和返回</li>
</ul>
</li>
<li>
<p>栈的优点</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个：
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li><strong>对于栈来说不存在垃圾回收问题</strong>
<ul>
<li>对于程序计数器：不存在GC，不存在OOM</li>
<li>对于栈：不存在GC, 存在OOM</li>
</ul>
</li>
</ul>
</li>
<li>
<p>栈中可能出现的异常</p>
<p><strong>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的</strong></p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackOverflowError异常</strong></li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展时无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError异常</strong></li>
</ul>
</li>
<li>
<p>设置栈内存大小</p>
<ul>
<li>
<p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<p>参考：<a href="url">https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html</a></p>
<p><img src="/images/jvm/5/1.png" alt="image.png" /></p>
</li>
<li>
<p>代码演示</p>
<p>默认情况下，程序抛出StackOverflowError异常时i为10823</p>
<p><img src="/images/jvm/5/2.png" alt="image.png" /></p>
<p>设置-Xss参数后重新执行：</p>
<p><img src="/images/jvm/5/3.png" alt="image.png" /></p>
<p>程序抛出StackOverflowError异常时i为1873</p>
<p><img src="/images/jvm/5/4.png" alt="image.png" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="12-栈的存储单位"><a class="header" href="#12-栈的存储单位">1.2 栈的存储单位</a></h3>
<h4 id="121-栈中存储什么"><a class="header" href="#121-栈中存储什么">1.2.1 栈中存储什么</a></h4>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li>
<li><strong>在这个线程上正在执行的每个方法都各自有一个对应的栈帧</strong></li>
<li>栈帧是一个内存区块，是一个数据及，维系着方法执行过程中的各种数据信息</li>
</ul>
<h4 id="122-栈运行原理"><a class="header" href="#122-栈运行原理">1.2.2 栈运行原理</a></h4>
<ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<strong>先进后出/后进先出</strong>的原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>，与大年栈帧对应的方法就是<strong>当前方法(Current Method)</strong>，定义这个方法的类就是<strong>当前类(Current Class)</strong></li>
<li><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong></li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</li>
</ul>
<p><img src="/images/jvm/5/5.png" alt="image.png" /></p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常（即未捕获异常）。</strong> 不管使用哪种方式，都会导致栈帧被弹出</li>
</ul>
<h4 id="123-栈帧的内部结构"><a class="header" href="#123-栈帧的内部结构">1.2.3 栈帧的内部结构</a></h4>
<p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表（Local Variables，主要影响栈帧大小)</strong></li>
<li><strong>操作数栈 (Operand Stack) (或表达式栈)</strong></li>
<li>动态链接 (Dynamic Linking) (或指向运行时常量池的方法引用)</li>
<li>方法返回地址 (Return Address) (或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息
其中，<strong>动态链接</strong>、<strong>方法返回地址</strong>和<strong>附加信息</strong>，有时统称为<strong>帧数据区</strong>。</li>
</ul>
<p><img src="/images/jvm/5/6.png" alt="image.png" /></p>
<h3 id="13-局部变量表-local-variables"><a class="header" href="#13-局部变量表-local-variables">1.3 局部变量表 (Local Variables)</a></h3>
<h4 id="131-概述"><a class="header" href="#131-概述">1.3.1 概述</a></h4>
<ul>
<li>
<p>局部变量表也被称之为局部变量数组或本地变量表</p>
</li>
<li>
<p>定义为一个<strong>数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型（8种）、对象引用（reference），以及returnAddress类型</p>
</li>
<li>
<p>由于局部变量表是建立在线程的栈上，是线程私有数据，因此<strong>不存在数据安全问题</strong></p>
</li>
<li>
<p><strong>局部变量表所需的容量大小是在编译起确定下来的</strong>，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表大小的</p>
</li>
<li>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</p>
</li>
<li>
<p>局部变量表的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</p>
<p>代码测试</p>
<pre><code class="language-java">package com.nasuf.jvm;

import java.util.Date;

public class LocalVariableTest {
    private int count = 0;

    public static void main(String[] args) {
        LocalVariableTest test = new LocalVariableTest();
        int num = 10;
        test.test1();
    }

    public void test1() {
        Date date = new Date();
        String name1 = &quot;nasuf&quot;;
        String info = test2(date, name1);
        System.out.println(date + name1);
    }
}
</code></pre>
<p>使用javap反编译后查看main方法部分输出如下：</p>
<pre><code class="language-java">    public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1    // 笔者注：此处locals=3表示局部变量表的最大容量为3
         0: new           #3                  // class com/nasuf/jvm/LocalVariableTest
         3: dup
         4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: bipush        10
        10: istore_2
        11: aload_1
        12: invokevirtual #5                  // Method test1:()V
        15: return
      LineNumberTable:
        line 9: 0
        line 10: 8
        line 11: 11
        line 12: 15
      LocalVariableTable:    // 笔者注：局部变量表
        Start  Length  Slot  Name   Signature
            0      16     0  args   [Ljava/lang/String;    // 笔者注：L表示引用类型，此处表示方法参数args
            8       8     1  test    Lcom/nasuf/jvm/LocalVariableTest;    // 笔者注： test表示局部变量test  
           11       5     2   num   I    // 笔者注：I表示Int类型，变量num
</code></pre>
<p>同样可以使用jclasslib查看字节码中main方法局部变量表的信息：
<img src="/images/jvm/5/7.png" alt="image.png" />
<img src="/images/jvm/5/8.png" alt="image.png" /></p>
<p>下图表示字节码指令的行号和Java代码行号的对应关系</p>
<p><img src="/images/jvm/5/9.png" alt="image.png" /></p>
<p>结合下列字节码信息</p>
<p><img src="/images/jvm/5/10.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/11.png" alt="image.png" /></p>
</li>
<li>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
</li>
<li>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p>
</li>
</ul>
<h4 id="132-关于slot的理解"><a class="header" href="#132-关于slot的理解">1.3.2 关于Slot的理解</a></h4>
<ul>
<li>
<p>参数值的存放总是在局部变量表数组的index0开始，到数组长度-1的索引结束</p>
</li>
<li>
<p>局部变量表，最基本的存储单元是slot（变量槽）</p>
</li>
<li>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</strong></p>
<ul>
<li>byte,short,char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
<p><img src="/images/jvm/5/12.png" alt="image.png" /></p>
</li>
<li>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个Slot上</strong></p>
</li>
<li>
<p><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问long或double类型变量）</p>
<p><img src="/images/jvm/5/13.png" alt="image.png" /></p>
</li>
<li>
<p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的Slot处</strong>，其余的参数按照参数表顺序继续排列；对于静态方法，this变量不存在与当前方法的局部变量表中，因而无法使用this引用</p>
<p><img src="/images/jvm/5/14.png" alt="image.png" /></p>
</li>
<li>
<p><strong>Slot是可以重用的</strong>。如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的</p>
<p><img src="/images/jvm/5/15.png" alt="image.png" /></p>
</li>
</ul>
<h4 id="133-各类变量的对比"><a class="header" href="#133-各类变量的对比">1.3.3 各类变量的对比</a></h4>
<ul>
<li>
<p>Java变量分类：</p>
<ul>
<li>按照数据类型：
<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置：
<ul>
<li>成员变量 (在使用前，都经历过默认初始化赋值)：
<ul>
<li>静态变量（或称为类变量，在linking的prepare阶段，给类变量默认赋值；在initial阶段给类变量显式赋值，即静态代码块赋值）</li>
<li>实例变量（随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值)</li>
</ul>
</li>
<li>局部变量 (在使用前，必须要显式赋值，否则编译不通过；不存在系统默认初始化赋值过程)</li>
</ul>
</li>
</ul>
<p><img src="/images/jvm/5/16.png" alt="image.png" /></p>
</li>
</ul>
<h3 id="14-操作数栈-operand-stack"><a class="header" href="#14-操作数栈-operand-stack">1.4 操作数栈 (Operand Stack)</a></h3>
<ul>
<li>每一个独立的栈帧中，除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为<strong>表达式栈（Expression Stack）</strong></li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈push/出栈pop
<ul>
<li>某些字节码指令将值亚茹操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈；比如执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<p><img src="/images/jvm/5/17.png" alt="image.png" /></p>
<ul>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，<strong>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</strong></li>
<li>每一个操作数栈都会有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了（<strong>操作数栈数据结构方面是用数组实现的</strong>），保存在方法的Code属性中，为max_stack的值
<img src="/images/jvm/5/18.png" alt="image.png" />
使用javap反编译字节码后输出也可以查看操作数栈的最大深度：
<img src="/images/jvm/5/19.png" alt="image.png" /></li>
<li>栈中的任何一个元素都可以是任意的Java数据类型
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式进行数据访问</strong>，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li>
</ul>
<h4 id="141-代码追踪"><a class="header" href="#141-代码追踪">1.4.1 代码追踪</a></h4>
<pre><code class="language-java">public class OperandStackTest {

    public void testAddOperation() {
        // byte, short, boolean, char都以int型进行保存
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}
</code></pre>
<p><img src="/images/jvm/5/20.png" alt="image.png" /></p>
<p>字节码指令解析：</p>
<p><img src="/images/jvm/5/21.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/22.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/23.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/24.png" alt="image.png" />
针对具有返回值的方法调用，则会执行<strong>aload_0</strong>指令，将调用的方法返回值直接入栈操作数栈；同时如果方法具有返回值（如int型)，则对应的字节码指令为<strong>ireturn</strong></p>
<p><img src="/images/jvm/5/25.png" alt="image.png" /></p>
<h3 id="15-栈顶缓存技术-top-of-stack-cashing"><a class="header" href="#15-栈顶缓存技术-top-of-stack-cashing">1.5 栈顶缓存技术 (Top-of-Stack Cashing)</a></h3>
<ul>
<li>基于栈式架构的虚拟机所使用的的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读写次数</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong></li>
</ul>
<h3 id="16-动态链接-dynamic-linking"><a class="header" href="#16-动态链接-dynamic-linking">1.6 动态链接 (Dynamic Linking)</a></h3>
<ul>
<li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的是支持当前方法的代码能够实现动态链接，比如：invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用 (Symbolic Reference) 保存在class文件的常量池里</strong>。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
<li><strong>字节码文件中的常量池在JVM运行后，放入到方法区，成为运行时常量池</strong></li>
</ul>
<p><img src="/images/jvm/5/26.png" alt="image.png" /></p>
<p>比如针对下列代码：</p>
<pre><code class="language-java">public class DynamicLinkingTest {

    int num = 10;

    public void methodA() {
        System.out.println(&quot;methodA() ...&quot;);
    }

    public void methodB() {
        System.out.println(&quot;methodB() ...&quot;);
        methodA();
        num ++;
    }

}
</code></pre>
<p>使用javap编译字节码后部分输出:</p>
<p><img src="/images/jvm/5/27.png" alt="image.png" /></p>
<p>其中#3，#6等表示的就是指向常量池中的符号引用。常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
<p><img src="/images/jvm/5/28.png" alt="image.png" /></p>
<h3 id="17-方法的调用"><a class="header" href="#17-方法的调用">1.7 方法的调用</a></h3>
<h4 id="171-概述"><a class="header" href="#171-概述">1.7.1 概述</a></h4>
<p>在JVM中，将符号引用转换为调用方法的直接引用，与方法的绑定机制有关</p>
<ul>
<li>静态链接。当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接</li>
<li>动态链接。如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接</li>
</ul>
<p>对应的方法绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong></p>
<ul>
<li>早期绑定，指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定。这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
<li>晚期绑定，指被调用的<strong>目标方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法</strong>，这种绑定方式称之为晚期绑定</li>
</ul>
<p>代码演示</p>
<pre><code class="language-java">package com.nasuf.jvm;

class Animal {
    public void eat() {
        System.out.println(&quot;动物进食&quot;);
    }
}

interface Huntable {
    void hunt();
}

class Dog extends Animal implements Huntable {

    @Override
    public void eat() {
        System.out.println(&quot;狗吃骨头&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;狗捕食&quot;);
    }
}

class Cat extends Animal implements Huntable {

    public Cat() {
        super();    // 早期绑定
    }

    public Cat(String name) {
        this();     // 早期绑定
    }
    @Override
    public void eat() {
        super.eat();
        System.out.println(&quot;猫吃鱼&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;猫捕食&quot;);
    }
}

public class AnimalTest {
    public void showAnimal(Animal animal) {
        animal.eat();   // 晚期绑定
    }

    public void showHun(Huntable h) {
        h.hunt();   // 晚期绑定
    }
}
</code></pre>
<p>查看AnimalTest类的字节码如下：</p>
<p><img src="/images/jvm/5/29.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/30.png" alt="image.png" /></p>
<p>查看Cat类的字节码如下：</p>
<p><img src="/images/jvm/5/31.png" alt="image.png" /></p>
<p><img src="/images/jvm/5/32.png" alt="image.png" /></p>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持<strong>封装、继承和多态等面向对象特性</strong>，既然这一类编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p><strong>Java中任何一个普通的方法其实都具备虚函数的特征（即晚期绑定），他们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法（方法不允许重写，在编译期确定，不具备多态特征）</strong></p>
<h4 id="172-虚方法与非虚方法"><a class="header" href="#172-虚方法与非虚方法">1.7.2 虚方法与非虚方法</a></h4>
<p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<strong>非虚方法</strong>。<strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong>，其他方法称为虚方法</p>
<p>虚拟机中提供了一下几条方法调用指令：</p>
<ul>
<li>普通调用指令：
<ul>
<li><strong>invokestatic</strong>: 调用静态方法，解析阶段确定唯一方法版本</li>
<li><strong>invokespecial</strong>: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li><strong>invokevirtual</strong>: 调用所有虚方法</li>
<li><strong>invokeinterface</strong>: 调用接口方法</li>
</ul>
</li>
<li>动态调用指令：
<ul>
<li><strong>invokedynamic</strong>: 动态解析出需要调用的方法，然后执行
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中财增加了一个invokedynamic指令，这是Java为了实现<strong>动态类型语言</strong>支持而做的一种改进</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令在Java中才有了直接的生成方式
<img src="/images/jvm/5/33.png" alt="image.png" /></li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器
前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码及对应字节码指令解析如下：</p>
<pre><code class="language-java">package com.nasuf.jvm;

class Father {
    public Father() {
        System.out.println(&quot;father的构造器&quot;);
    }

    public static void showStatic(String str) {
        System.out.println(&quot;father &quot; + str);
    }

    public final void showFinal() {
        System.out.println(&quot;father show final&quot;);
    }

    public void showCommon() {
        System.out.println(&quot;father普通方法&quot;);
    }
}

public class Son extends Father {
    public Son() {
        // invokespecial 非虚方法
        super();
    }

    public Son (int age) {
        // invokespecial 非虚方法
        this();
    }

    /**
     * 静态方法不能被重写，尽管此处的方法签名跟父类方法完全一致
     * @param str
     */
    public static void showStatic(String str) {
        System.out.println(&quot;son &quot; + str);
    }

    private void showPrivate(String str) {
        System.out.println(&quot;son private &quot; + str);
    }

    public void show() {
        // invokestatic 非虚方法
        showStatic(&quot;nasuf&quot;);

        // invokestatic 非虚方法
        super.showStatic(&quot;good&quot;);

        // invokespecial 非虚方法
        showPrivate(&quot;hello&quot;);

        // invokespecial 非虚方法
        super.showCommon();

        // invokevirtual 因为showFinal()方法为父类的final方法，不能被子类重写，
        // 所以此处依然是非虚方法
        showFinal();
        // 如果明确引用父类的showFinal()方法，则此处对应的字节码指令则变为invokespecial
        // super.showFinal()

        // invokevirtual 因为没有明确指定super.showCommon()，该方法可能被子类重写，在编译期无法确定
        // 因此为虚方法
        showCommon();

        // invokevirtual
        info();

        MethodInterface methodInterface = null;
        // invokeinterface 虚方法，在执行时必须被实现类实现
        methodInterface.methodA();
    }

    public void info() { }

    public void display(Father f) {
        f.showCommon();
    }

    public static void main(String[] args) {
        Son son =  new Son();
        son.show();
    }

}

interface MethodInterface {
    void methodA();
}
</code></pre>
<h4 id="173-动态类型语言和静态类型语言"><a class="header" href="#173-动态类型语言和静态类型语言">1.7.3 动态类型语言和静态类型语言</a></h4>
<p>两者的区别在于对类型的检查是在编译期还是再运行期，满足前者的就是静态类型语言，反之是动态类型语言。换言之，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。Java属于静态类型语言（函数式编程lambda表达式赋予Java动态语言的一些特性），Javascript/Python属于动态类型语言</p>
<h4 id="174-方法重写的本质"><a class="header" href="#174-方法重写的本质">1.7.4 方法重写的本质</a></h4>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常</li>
<li>否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li>
</ol>
<p><strong>IllegalAccessError</strong>：程序试图访问或修改一个属性或调用一个方法，这个属性或方法没有权限访问。一般这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</p>
<h4 id="175-虚方法表"><a class="header" href="#175-虚方法表">1.7.5 虚方法表</a></h4>
<ul>
<li>在面向对象的编程中，会很频繁地使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区简历一个<strong>虚方法表 (virtual method table)（非虚方法不会出现在表中）来实现。使用索引表来代替查找</strong></li>
<li><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</strong></li>
<li><strong>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</strong></li>
</ul>
<p>举例1：</p>
<p><img src="/images/jvm/5/34.png" alt="image.png" /></p>
<p>举例2：</p>
<p><img src="/images/jvm/5/35.png" alt="image.png" />
代码：</p>
<pre><code class="language-java">package com.nasuf.jvm;

interface Friendly {
    void sayHello();
    void sayGoodbye();
}

class Dog {
    public void sayHello() { }
    
    public String toString() {
        return &quot;Dog&quot;;
    }
}

class Cat implements Friendly {

    public void eat() { }

    @Override
    public void sayHello() { }

    @Override
    public void sayGoodbye() { }

    protected void finalize() { }

    public String toString() {
        return &quot;Cat&quot;;
    }
}

class CockerSpaniel extends Dog implements Friendly {

    public void sayHello() {
        super.sayHello();
    }

    @Override
    public void sayGoodbye() { }
}

public class VirtualMethodTable {
}

</code></pre>
<p>Dog虚方法表</p>
<p><img src="/images/jvm/5/36.png" alt="image.png" /></p>
<p>CockerSpaniel虚方法表</p>
<p><img src="/images/jvm/5/37.png" alt="image.png" /></p>
<p>Cat虚方法表</p>
<p><img src="/images/jvm/5/38.png" alt="image.png" /></p>
<h3 id="18-方法返回地址return-address"><a class="header" href="#18-方法返回地址return-address">1.8 方法返回地址（Return Address）</a></h3>
<ul>
<li>存放调用该方法的PC寄存器的值（PC寄存器中存储的是该方法要执行的下一条指令的值）</li>
<li>一个方法的结束，有两种方式：
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层方法调用者，简称<strong>正常完成出口</strong>；
<ul>
<li>一个方法在正常调用完成之后酒井需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean,byte,char,shor,int类型时使用）、lreturn、freturn、dreturn、areturn，另外还有一个return指令供声明为void的方法、实力初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
<li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
</li>
<li>无论哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</li>
<li>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</strong></li>
</ul>
<pre><code class="language-java">package com.nasuf.jvm;

import java.io.FileReader;
import java.io.IOException;
import java.util.Date;

public class ReturnAddressTest {

    // 默认构造器也是return

    // ireturn
    public boolean methodBoolean() { return false; }

    // ireturn
    public byte methodByte() { return 0; }

    // ireturn
    public short methodShort() { return 0; }

    // ireturn
    public char methodChar() { return 'a'; }

    // ireturn
    public int methodInt() { return 0; }

    // lreturn
    public long methodLong() { return 0L; }

    // freturn
    public float methodFloat() { return 0.0f; }

    // dreturn
    public double methodDouble() { return 0.0; }

    // areturn:引用类型
    public String methodString() { return null; }

    // areturn:引用类型
    public Date methodDate() { return null; }

    // return
    public void methodVoid() { }

    static {
        int i = 10;
    }

    public void method2() {
        try {
            method1();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void method1() throws IOException {
        FileReader fis = new FileReader(&quot;test.txt&quot;);
        char[] cBuffer = new char[1024];
        int len;
        while((len = fis.read(cBuffer)) != -1) {
            String str = new String(cBuffer, 0, len);
            System.out.println(str);
        }
        fis.close();
    }
}
</code></pre>
<p>执行javap对应method2输出如下（注意<strong>Exception table</strong>）：</p>
<pre><code class="language-java">public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=2, args_size=1
         0: aload_0
         1: invokevirtual #2                  // Method method1:()V
         4: goto          12
         7: astore_1
         8: aload_1
         9: invokevirtual #4                  // Method java/io/IOException.printStackTrace:()V
        12: return
      Exception table:
         from    to  target type
             0     4     7   Class java/io/IOException    
      LineNumberTable:
        line 50: 0
        line 53: 4
        line 51: 7
        line 52: 8
        line 54: 12
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            8       4     1     e   Ljava/io/IOException;
            0      13     0  this   Lcom/nasuf/jvm/ReturnAddressTest;
      StackMapTable: number_of_entries = 2
        frame_type = 71 /* same_locals_1_stack_item */
          stack = [ class java/io/IOException ]
        frame_type = 4 /* same */
</code></pre>
<p>表明如果代码从字节码指令0到4的范围内（代码行号范围为50到53）出现异常，按照字节码指令7（代码行号51）的位置进行处理：
<img src="/images/jvm/5/39.png" alt="image.png" /></p>
<h3 id="19-一些附加信息"><a class="header" href="#19-一些附加信息">1.9 一些附加信息</a></h3>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</p>
<h3 id="110-面试题方法中定义的局部变量是否线程安全"><a class="header" href="#110-面试题方法中定义的局部变量是否线程安全">1.10 面试题：方法中定义的局部变量是否线程安全？</a></h3>
<p>代码解析：</p>
<pre><code class="language-java">package com.nasuf.jvm;

/**
 * StringBuilder本身不是线程安全的
 */
public class StringBuilderTest {

    /**
     * s1在方法内部声明，只在方法内部使用，是线程安全的
     */
    public static void method1() {
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        // ...
    }

    /**
     * s2由方法外部传入，不是线程安全的
     */
    public static void method2(StringBuilder s2) {
        s2.append(&quot;a&quot;);
        s2.append(&quot;b&quot;);
    }

    /**
     * s3由方法返回，可能被其他线程调用，不是线程安全的
     */
    public static StringBuilder method3() {
        StringBuilder s3 = new StringBuilder();
        s3.append(&quot;a&quot;);
        s3.append(&quot;b&quot;);
        return s3;
    }

    /**
     * s4是线程安全的, 查看StringBuilder的toString()方法源码如下，实际上是返回了一个新String对象
     * 该对象本身是线程不安全的，因为返回给外部，会被其他线程调用
     *     @Override
     *     public String toString() {
     *         // Create a copy, don't share the array
     *         return new String(value, 0, count);
     *     }
     */
    public static String method4() {
        StringBuilder s4 = new StringBuilder();
        s4.append(&quot;a&quot;);
        s4.append(&quot;b&quot;);
        return s4.toString();
    }
}
</code></pre>
<h2 id="2-本地方法栈"><a class="header" href="#2-本地方法栈">2. 本地方法栈</a></h2>
<p><img src="/images/jvm/5/40.png" alt="image.png" /></p>
<ul>
<li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></li>
<li>本地方法栈，也是<strong>线程私有</strong>的</li>
<li>允许被实现成固定或者可动态扩展的内存大小。在内存溢出方面是相同的
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackOverflowError</strong>异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的本地方法栈，那么Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>
</li>
<li>本地方法是使用C语言实现的</li>
<li><strong>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库</strong></li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong>
<ul>
<li>本地方法可以通过本地接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li><strong>并不是所有的JVM都支持本地方法</strong>。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现</li>
<li><strong>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</strong></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../JVM/04_本地方法接口.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Rust/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../JVM/04_本地方法接口.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Rust/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
