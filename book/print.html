<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NASUF Dev Notes</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="JVM/index.html"><strong aria-hidden="true">1.</strong> Jvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="JVM/01_概览.html"><strong aria-hidden="true">1.1.</strong> 概览</a></li><li class="chapter-item expanded "><a href="JVM/02_类加载子系统.html"><strong aria-hidden="true">1.2.</strong> 类加载子系统</a></li><li class="chapter-item expanded "><a href="JVM/03_运行时数据区（线程和程序计数器）.html"><strong aria-hidden="true">1.3.</strong> 运行时数据区（线程和程序计数器）</a></li><li class="chapter-item expanded "><a href="JVM/04_本地方法接口.html"><strong aria-hidden="true">1.4.</strong> 本地方法接口</a></li><li class="chapter-item expanded "><a href="JVM/05_运行时数据区（虚拟机栈和本地方法栈）.html"><strong aria-hidden="true">1.5.</strong> 运行时数据区（虚拟机栈和本地方法栈）</a></li></ol></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rust/01_生命周期（基础理解）.html"><strong aria-hidden="true">2.1.</strong> 生命周期-基础理解</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NASUF Dev Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jvm系列笔记"><a class="header" href="#jvm系列笔记">JVM系列笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-jvm-整体结构"><a class="header" href="#1-jvm-整体结构">1. JVM 整体结构</a></h2>
<h3 id="简图"><a class="header" href="#简图">简图</a></h3>
<p><img src="JVM//images/jvm/1/1.png" alt="image.png" /></p>
<h3 id="详细图"><a class="header" href="#详细图">详细图</a></h3>
<p><img src="JVM//images/jvm/1/2.png" alt="image.png" /></p>
<ul>
<li>类装载子系统：将class file装载到内存中，生成<strong>Class</strong>对象，其中涉及到加载、链接、初始化等步骤；</li>
<li>运行时数据区：方法区和堆是多线程共享，Java栈、本地方法栈、程序计数器是线程独享</li>
<li>执行引擎：将字节码指令解释翻译成机器指令</li>
</ul>
<h2 id="2-java-代码执行流程"><a class="header" href="#2-java-代码执行流程">2. Java 代码执行流程</a></h2>
<p><img src="JVM//images/jvm/1/3.png" alt="image.png" /></p>
<h2 id="3-jvm-架构模型"><a class="header" href="#3-jvm-架构模型">3. JVM 架构模型</a></h2>
<p>Java编译器输入的指令流基本上是基于一种基于<strong>栈的指令集架构</strong>，另外一种指令集架构是基于<strong>寄存器的指令集架构</strong>。两者区别：</p>
<ul>
<li>基于栈式架构的特点：
<ol>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用<strong>零地址指令方式分配</strong>；</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。<strong>指令集更小</strong>，编译器容易实现；</li>
<li>不需要硬件支持，<strong>可移植性更好</strong>，更好实现跨平台。</li>
</ol>
</li>
<li>基于寄存器
<ol>
<li>指令集架构完全依赖硬件，<strong>可移植性查</strong>；</li>
<li><strong>性能优秀和执行更高效</strong>；</li>
<li><strong>花费更少的指令</strong>去完成一项操作；</li>
<li>指令集往往都以一地址指令，二地址指令和三地址指令为主。</li>
</ol>
</li>
</ul>
<p><em>代码测试：</em></p>
<pre><code class="language-java">public class StackStructure {

    public static void main(String[] args) {
        int a = 2;
        int b = 3;
        int c = a + b;
    }
}
</code></pre>
<p>编译后执行以下命令进行反编译：</p>
<pre><code class="language-shell">javap -v StackStructure.class
</code></pre>
<p>输出部分如下：</p>
<pre><code class="language-java">public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_2
         1: istore_1
         2: iconst_3
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: istore_3
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 2
        line 8: 4
        line 9: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            2       7     1     a   I
            4       5     2     b   I
            8       1     3     c   I
</code></pre>
<h2 id="4-jvm-生命周期"><a class="header" href="#4-jvm-生命周期">4. JVM 生命周期</a></h2>
<ul>
<li>
<p>虚拟机的启动</p>
<p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
</li>
<li>
<p>虚拟机的执行</p>
<p>一个运行中的Java虚拟机有一个清晰的任务：java程序的执行。程序开始执行时，JVM才开始运行，程序结束就停止；执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java的虚拟机进程。</p>
</li>
<li>
<p>虚拟机的退出</p>
<p>有如下几种退出方式：</p>
<ol>
<li>程序正常执行结束；</li>
<li>程序在执行过程中遇到了异常或错误而异常终止；</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止；</li>
<li>某线程调用<strong>Runtime</strong>类或<strong>System</strong>类的<strong>exit</strong>方法，或<strong>Runtime</strong>类的<strong>halt</strong>方法，并且java安全管理器也允许这次exit或halt操作；</li>
<li>JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-类加载子系统作用"><a class="header" href="#1-类加载子系统作用">1. 类加载子系统作用</a></h2>
<p><img src="JVM//Images/jvm/2/1.png" alt="image.png" /></p>
<ul>
<li>类加载子系统负责从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识；</li>
<li>ClassLoader只负责Class文件的加载，至于它是否可以运行，则由Execution Engine决定；</li>
<li>加载的类信息存放于一块成为方法区的内存空间。除了类的信息外，<strong>方法区</strong>中还会存放<strong>运行时常量池</strong>信息，可能还包括<strong>字符串字面量</strong>和<strong>数字常量</strong>（这部分常量信息是Class文件中常量池部分的内存映射）
注：运行时常量池，如下列代码</li>
</ul>
<pre><code class="language-java">public class StackStructure {

    public static void main(String[] args) {
        int a = 2;
        int b = 3;
        int c = a + b;
    }
}
</code></pre>
<p>反编译后的部分输出</p>
<pre><code class="language-java">Constant pool:
   #1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #22            // com/nasuf/jvm/StackStructure
   #3 = Class              #23            // java/lang/Object
   #4 = Utf8               &lt;init&gt;
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/nasuf/jvm/StackStructure;
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               args
  #14 = Utf8               [Ljava/lang/String;
  #15 = Utf8               a
  #16 = Utf8               I
  #17 = Utf8               b
  #18 = Utf8               c
  #19 = Utf8               SourceFile
  #20 = Utf8               StackStructure.java
  #21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V
  #22 = Utf8               com/nasuf/jvm/StackStructure
  #23 = Utf8               java/lang/Object
</code></pre>
<p>上述常量池信息在运行时加载到内存中，就成为<strong>运行时常量池</strong>。</p>
<h2 id="2-类加载器classloader角色"><a class="header" href="#2-类加载器classloader角色">2. 类加载器ClassLoader角色</a></h2>
<p><img src="JVM//images/jvm/2/2.png" alt="image.png" /></p>
<ul>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是以<strong>二进制流</strong>加载到JVM当中来根据这个文件实例化出n个一模一样的实例；</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区；</li>
<li>在.class文件 -&gt; JVM -&gt; 最终称为元数据模板，此过程就要一个运输工具（类加载器ClassLoader)，扮演一个快递员的角色</li>
</ul>
<h2 id="3-类的加载过程"><a class="header" href="#3-类的加载过程">3. 类的加载过程</a></h2>
<p><img src="JVM//images/jvm/2/3.png" alt="image.png" /></p>
<h3 id="31-加载"><a class="header" href="#31-加载">3.1 加载</a></h3>
<ol>
<li>通过一个类的<strong>全限定名</strong>获取定义此类的<strong>二进制字节流</strong>；</li>
<li>将这个字节流所代表的的<strong>静态存储结构转化为方法区的运行时数据结构</strong>；</li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。
<strong>加载class文件的方式</strong></li>
</ol>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有数据库中提取class文件，比较少见</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
<h3 id="32-链接"><a class="header" href="#32-链接">3.2 链接</a></h3>
<h4 id="321-验证verify"><a class="header" href="#321-验证verify">3.2.1 验证（Verify）</a></h4>
<ul>
<li>
<p>目的在于确保class文件的字节流中更包含的信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全；</p>
</li>
<li>
<p>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证；比如查看下列字节码文件，字节码应以<strong>CA FE BA BE</strong>开头：</p>
<p><img src="JVM//images/jvm/2/4.png" alt="image.png" /></p>
</li>
</ul>
<h4 id="322-准备prepare"><a class="header" href="#322-准备prepare">3.2.2 准备（Prepare）</a></h4>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值；</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一期分配到Java堆中</li>
</ul>
<h4 id="323-解析resolve"><a class="header" href="#323-解析resolve">3.2.3 解析（Resolve）</a></h4>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程；</li>
<li>事实上，解析操作往往伴随着JVM在执行完初始化之后再执行；</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中，直接饮用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄；</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li>
</ul>
<h3 id="33-初始化"><a class="header" href="#33-初始化">3.3 初始化</a></h3>
<ul>
<li>初始化阶段就是执行类的构造器方法&lt;clinit&gt;()的过程；</li>
<li>此方法不需定义，是javac编译器自动手机类中的所有类变量的赋值动作和静态代码块中的语句合并而来；</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行；</li>
<li>&lt;clinint&gt;()不同于类的构造器（关联：构造器是虚拟机视角下的&lt;init&gt;());</li>
</ul>
<p>查看如下代码字节码信息：</p>
<p><img src="JVM//images/jvm/2/5.png" alt="image.png" /></p>
<p>修改代码再次查看，及&lt;clinit&gt;()方法会将代码中显示初始化的值合并：</p>
<p><img src="JVM//images/jvm/2/6.png" alt="image.png" /></p>
<p>修改代码查看赋值过程：</p>
<p><img src="JVM//images/jvm/2/7.png" alt="image.png" /></p>
<p>而如果类中不存在静态变量或静态代码块，则字节码中不会存在&lt;clinit&gt;()方法：
（注：&lt;init&gt;方法是类的构造器方法）</p>
<p><img src="JVM//images/jvm/2/8.png" alt="image.png" /></p>
<ul>
<li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕；</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁；例如如下代码，两个线程启动后，只会有一个线程会初始化DeatThread类</li>
</ul>
<p><img src="JVM//images/jvm/2/9.png" alt="image.png" /></p>
<h2 id="4-类加载器的分类"><a class="header" href="#4-类加载器的分类">4. 类加载器的分类</a></h2>
<h3 id="41-概述"><a class="header" href="#41-概述">4.1 概述</a></h3>
<ul>
<li>JVM支持两种类型的类加载器，分别是<strong>引导类加载器（Bootstrap ClassLoader，非java语言编写）和自定义类加载器（User-Defined ClassLoader， java语言编写）</strong></li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范中定义，<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>，那么平常所说的扩展类加载器和应用类加载器都属于自定义类加载器(均间接继承了ClassLoader class）</li>
</ul>
<p><img src="JVM//images/jvm/2/10.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/2/11.png" alt="image.png" /></p>
<p>ExtClassLoader.class</p>
<p><img src="JVM//images/jvm/2/12.png" alt="image.png" /></p>
<p>AppClassLoader.class</p>
<p><img src="JVM//images/jvm/2/13.png" alt="image.png" /></p>
<p>打印出各层类加载器：</p>
<p><img src="JVM//images/jvm/2/14.png" alt="image.png" /></p>
<h3 id="42-启动类加载器引导类加载器bootstrap-classloader"><a class="header" href="#42-启动类加载器引导类加载器bootstrap-classloader">4.2 启动类加载器（引导类加载器，Bootstrap ClassLoader)</a></h3>
<ul>
<li>这个类加载使用C/C++语言实现，嵌套在JVM内部；</li>
<li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar, resources.jar或sun.boot.class.path路径下的内容）用于提供JVM自身需要的类；</li>
<li><strong>并不继承自java.lang.ClassLoader,没有父加载器</strong>；</li>
<li>加载拓展类和应用程序类加载器，并指定为为他们的父类加载器；</li>
<li>处于安全考虑，<strong>Bootstrap启动类加载器只加载包名为java/javax/sun等开头的类</strong></li>
</ul>
<h3 id="43-拓展类加载器extension-classloader"><a class="header" href="#43-拓展类加载器extension-classloader">4.3 拓展类加载器（Extension ClassLoader)</a></h3>
<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现；</li>
<li><strong>派生于ClassLoader类；</strong></li>
<li>父类加载器为启动类加载器；</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</strong></li>
</ul>
<h3 id="44-应用程序类加载器系统类加载器appclassloader"><a class="header" href="#44-应用程序类加载器系统类加载器appclassloader">4.4 应用程序类加载器（系统类加载器，AppClassLoader)</a></h3>
<ul>
<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现；</li>
<li><strong>派生于ClassLoader类；</strong></li>
<li>父类加载器为扩展类加载器；</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库；</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载；</li>
<li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src="JVM//images/jvm/2/15.png" alt="image.png" /></p>
<h3 id="45-用户自定义类加载器"><a class="header" href="#45-用户自定义类加载器">4.5 用户自定义类加载器</a></h3>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3中类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<h4 id="451-自定义类加载器目的"><a class="header" href="#451-自定义类加载器目的">4.5.1 自定义类加载器目的</a></h4>
<ul>
<li>隔离加载类</li>
<li>修改类加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<h4 id="452-自定义类加载器步骤"><a class="header" href="#452-自定义类加载器步骤">4.5.2 自定义类加载器步骤</a></h4>
<ol>
<li>开发人员可以通过继承抽象类<strong>java.lang.ClassLoader</strong>类的方式，实现自己的类加载器，以满足一些特殊需求；</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中；</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<strong>URLClassLoader</strong>类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<h3 id="46-关于classloader"><a class="header" href="#46-关于classloader">4.6 关于ClassLoader</a></h3>
<p>ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<div class="table-wrapper"><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody>
<tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr>
<tr><td>loadClass(String name)</td><td>加载名为name的类，返回结果为java.lang.Class类的实例</td></tr>
<tr><td>findClass(String name)</td><td>查找名为name的类，返回结果为java.lang.Class类的实例</td></tr>
<tr><td>findLoadedClass(String name)</td><td>查找名为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr>
<tr><td>defineClass(String name, byte[] b, int off, int len</td><td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td></tr>
<tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个Java类</td></tr>
</tbody></table>
</div>
<h2 id="5-双亲委派机制"><a class="header" href="#5-双亲委派机制">5. 双亲委派机制</a></h2>
<p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h3 id="51-工作原理"><a class="header" href="#51-工作原理">5.1 工作原理</a></h3>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载其，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此家在任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li>
</ol>
<p><img src="JVM//images/jvm/2/16.png" alt="image.png" /></p>
<h3 id="52-沙箱安全机制"><a class="header" href="#52-沙箱安全机制">5.2 沙箱安全机制</a></h3>
<p>例如我们自定义包为java.lang并创建同名String.java，执行main方法，则会报错如下：</p>
<p><img src="JVM//images/jvm/2/17.png" alt="image.png" /></p>
<p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护。这就是<strong>沙箱安全机制</strong></p>
<p>如果我们在自定义java.lang包下创建其他不在rt.jar包下定义的class，则会报错如下：</p>
<p><img src="JVM//images/jvm/2/18.png" alt="image.png" /></p>
<h3 id="53-优势"><a class="header" href="#53-优势">5.3 优势</a></h3>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<h2 id="6-其他"><a class="header" href="#6-其他">6. 其他</a></h2>
<h3 id="61-两个class对象是否为同一个类的两个必要条件"><a class="header" href="#61-两个class对象是否为同一个类的两个必要条件">6.1 两个class对象是否为同一个类的两个必要条件：</a></h3>
<ul>
<li>类的完整类名必须一致，包括包名；</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同；换句话说，在JVM中，即使这两个类对象（class对象）来源同一个class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类也是不相等的</li>
</ul>
<h3 id="62-对类加载器的引用"><a class="header" href="#62-对类加载器的引用">6.2 对类加载器的引用</a></h3>
<p>JVM必须知道一个类型是由启动类加载器加载还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用时，JVM需要保证这两个类型的类加载器是相同的</p>
<h3 id="63-类的主动使用和被动使用"><a class="header" href="#63-类的主动使用和被动使用">6.3 类的主动使用和被动使用</a></h3>
<ul>
<li>主动使用（分为7种情况）
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射，比如Class.forName(&quot;com.nasuf.test&quot;)</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化（即上文中提到的类加载过程中的初始化环节）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-运行时数据区概述"><a class="header" href="#1-运行时数据区概述">1. 运行时数据区概述</a></h2>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p><img src="JVM//images/jvm/3/1.png" alt="image.png" /></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li>线程私有：程序计数器，栈，本地栈</li>
<li>线程共享：堆，堆外内存（永久代或元空间、代码缓存）
<em>可参考官方链接 https://docs.oracle.com/javase/specs/jvms/se8/html/</em></li>
</ul>
<h3 id="11-error-vs-gc"><a class="header" href="#11-error-vs-gc">1.1 Error vs GC</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>Error</th><th>GC</th></tr></thead><tbody>
<tr><td>程序计数器</td><td>×</td><td>×</td></tr>
<tr><td>虚拟机栈</td><td>√</td><td>×</td></tr>
<tr><td>本地方法栈</td><td>√</td><td>×</td></tr>
<tr><td>堆</td><td>√</td><td>√</td></tr>
<tr><td>方法区</td><td>√</td><td>√</td></tr>
</tbody></table>
</div>
<h2 id="2-线程"><a class="header" href="#2-线程">2. 线程</a></h2>
<ul>
<li>线程是一个程序里的运行单元，JVM允许一个应用程序有多个线程并行执行</li>
<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li>
<li>使用jconsole或者任何一个调试工具，都能看到在后台有许多的线程在运行。这些后台线程不包括调用public static void main(String[] args)的main线程以及所有这个main线程自己创建的线程；这些主要的后台系统线程在Hotspot虚拟机里主要是以下几个：
<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括&quot;stop-the-world&quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销；</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行；</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持；</li>
<li>编译线程：这种线程在运行时会将字节码编译成本地代码；</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ul>
</li>
</ul>
<h2 id="3-程序计数器pc-register"><a class="header" href="#3-程序计数器pc-register">3. 程序计数器（PC Register）</a></h2>
<h3 id="31-pc-register介绍"><a class="header" href="#31-pc-register介绍">3.1 PC Register介绍</a></h3>
<p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译成PC计数器（或指令计数器）则会更加贴切一些（也成为程序钩子）。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不计。也是<strong>运行速度最快的存储区域</strong></li>
<li>在JVM规范中，每个线程都有他自己的程序计数器，是<strong>线程私有</strong>的，生命周期与线程的生命周期保持一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM 指令地址；或者，如果是在执行native方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是<strong>唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong></li>
</ul>
<h3 id="32-作用"><a class="header" href="#32-作用">3.2 作用</a></h3>
<p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="JVM//images/jvm/3/2.png" alt="image.png" /></p>
<h3 id="33-代码演示"><a class="header" href="#33-代码演示">3.3 代码演示</a></h3>
<pre><code class="language-java">public class PCRegisterTest {
    public PCRegisterTest() {
    }

    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int var10000 = i + j;
    }
}
</code></pre>
<p>部分输出如下：</p>
<pre><code class="language-java">      stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: return
</code></pre>
<p>其中前面一列的数字表示<strong>指令地址（偏移地址）</strong>，是PC寄存机中实际存储的数据，后面一列为操作指令。<strong>执行引擎会从PC寄存器中存储的数据所代表的位置取相应的指令</strong>；执行引擎会操作局部变量表、操作数栈，并将字节码指令翻译成机器指令。</p>
<h3 id="34-问题"><a class="header" href="#34-问题">3.4 问题</a></h3>
<h4 id="341-使用pc寄存器存储字节码指令地址有什么用"><a class="header" href="#341-使用pc寄存器存储字节码指令地址有什么用">3.4.1 使用PC寄存器存储字节码指令地址有什么用</a></h4>
<p>因为CPU需要不停地切换各个线程，这时候切换回来以后，就得知道接着从哪里开始继续执行；JVM字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<h4 id="342-pc寄存器为什么会被设定为线程私有"><a class="header" href="#342-pc寄存器为什么会被设定为线程私有">3.4.2 PC寄存器为什么会被设定为线程私有</a></h4>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或护肤，如何保证分毫无差呢？为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<h3 id="35-cpu时间片"><a class="header" href="#35-cpu时间片">3.5 CPU时间片</a></h3>
<p>CPU时间片即CPU分配给各个程序的时间，每个程序被分配一个时间段，称作它的时间片。在宏观上，我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上，由于只有一个CPU， 一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="JVM//images/jvm/4/1.png" alt="image.png" /></p>
<h2 id="1-本地方法"><a class="header" href="#1-本地方法">1. 本地方法</a></h2>
<ul>
<li>一个<strong>Native Method</strong>就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern &quot;C&quot;告知C++编译器去调用一个C函数</li>
<li>在定义一个Native Method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</li>
<li>Native方法没有方法体
<pre><code class="language-java">public final native Class&lt;?&gt; getClass();
</code></pre>
但是这不代表该方法是<strong>abstract</strong>方法(两个关键字不可同时使用)：
<img src="JVM//images/jvm/4/2.png" alt="image.png" />
实际上，<strong>标识符native可以与所有除abstract之外的所有其他Java标识符连用</strong></li>
</ul>
<h3 id="11-为什么要使用本地方法"><a class="header" href="#11-为什么要使用本地方法">1.1 为什么要使用本地方法</a></h3>
<p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了</p>
<ul>
<li>
<p>与Java环境外交互</p>
<p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。可以想象Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正式这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节</p>
</li>
<li>
<p>与操作系统交互</p>
<p>JVM支撑着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持，这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法</p>
</li>
<li>
<p>Sun's Java</p>
<p>Sun的解释器是用C语言实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0(). 这个本地方法是用C语言实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API. 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用</p>
</li>
</ul>
<h2 id="12-现状"><a class="header" href="#12-现状">1.2 现状</a></h2>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-虚拟机栈"><a class="header" href="#1-虚拟机栈">1. 虚拟机栈</a></h2>
<h3 id="11-虚拟机栈概述"><a class="header" href="#11-虚拟机栈概述">1.1 虚拟机栈概述</a></h3>
<h4 id="111-虚拟机栈出现的背景"><a class="header" href="#111-虚拟机栈出现的背景">1.1.1 虚拟机栈出现的背景</a></h4>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<strong>优点是跨平台，指令集小；缺点是性能下降，实现同样的功能需要更多的指令。编译器容易实现</strong>。</p>
<h4 id="122-内存中的栈与堆"><a class="header" href="#122-内存中的栈与堆">1.2.2 内存中的栈与堆</a></h4>
<p><strong>栈时运行时的单位，而堆是存储的单位</strong>。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的问题是数据存储问题，即数据怎么放，放在哪儿。</p>
<h4 id="123-虚拟机栈基本内容"><a class="header" href="#123-虚拟机栈基本内容">1.2.3 虚拟机栈基本内容</a></h4>
<ul>
<li>
<p>Java虚拟机栈是什么</p>
<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用</li>
<li>是线程私有的</li>
</ul>
</li>
<li>
<p>生命周期</p>
<ul>
<li>生命周期和线程一致</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>主管Java程序的运行，它保存方法的局部变量（<strong>8种基本数据类型， 对象的引用地址</strong>），部分结果，并参与方法的调用和返回</li>
</ul>
</li>
<li>
<p>栈的优点</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM直接对Java栈的操作只有两个：
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li><strong>对于栈来说不存在垃圾回收问题</strong>
<ul>
<li>对于程序计数器：不存在GC，不存在OOM</li>
<li>对于栈：不存在GC, 存在OOM</li>
</ul>
</li>
</ul>
</li>
<li>
<p>栈中可能出现的异常</p>
<p><strong>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的</strong></p>
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建时独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackOverflowError异常</strong></li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展时无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError异常</strong></li>
</ul>
</li>
<li>
<p>设置栈内存大小</p>
<ul>
<li>
<p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<p>参考：<a href="JVM/url">https://docs.oracle.com/en/java/javase/11/tools/tools-and-command-reference.html</a></p>
<p><img src="JVM//images/jvm/5/1.png" alt="image.png" /></p>
</li>
<li>
<p>代码演示</p>
<p>默认情况下，程序抛出StackOverflowError异常时i为10823</p>
<p><img src="JVM//images/jvm/5/2.png" alt="image.png" /></p>
<p>设置-Xss参数后重新执行：</p>
<p><img src="JVM//images/jvm/5/3.png" alt="image.png" /></p>
<p>程序抛出StackOverflowError异常时i为1873</p>
<p><img src="JVM//images/jvm/5/4.png" alt="image.png" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="12-栈的存储单位"><a class="header" href="#12-栈的存储单位">1.2 栈的存储单位</a></h3>
<h4 id="121-栈中存储什么"><a class="header" href="#121-栈中存储什么">1.2.1 栈中存储什么</a></h4>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li>
<li><strong>在这个线程上正在执行的每个方法都各自有一个对应的栈帧</strong></li>
<li>栈帧是一个内存区块，是一个数据及，维系着方法执行过程中的各种数据信息</li>
</ul>
<h4 id="122-栈运行原理"><a class="header" href="#122-栈运行原理">1.2.2 栈运行原理</a></h4>
<ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循<strong>先进后出/后进先出</strong>的原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>，与大年栈帧对应的方法就是<strong>当前方法(Current Method)</strong>，定义这个方法的类就是<strong>当前类(Current Class)</strong></li>
<li><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong></li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</li>
</ul>
<p><img src="JVM//images/jvm/5/5.png" alt="image.png" /></p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常（即未捕获异常）。</strong> 不管使用哪种方式，都会导致栈帧被弹出</li>
</ul>
<h4 id="123-栈帧的内部结构"><a class="header" href="#123-栈帧的内部结构">1.2.3 栈帧的内部结构</a></h4>
<p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表（Local Variables，主要影响栈帧大小)</strong></li>
<li><strong>操作数栈 (Operand Stack) (或表达式栈)</strong></li>
<li>动态链接 (Dynamic Linking) (或指向运行时常量池的方法引用)</li>
<li>方法返回地址 (Return Address) (或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息
其中，<strong>动态链接</strong>、<strong>方法返回地址</strong>和<strong>附加信息</strong>，有时统称为<strong>帧数据区</strong>。</li>
</ul>
<p><img src="JVM//images/jvm/5/6.png" alt="image.png" /></p>
<h3 id="13-局部变量表-local-variables"><a class="header" href="#13-局部变量表-local-variables">1.3 局部变量表 (Local Variables)</a></h3>
<h4 id="131-概述"><a class="header" href="#131-概述">1.3.1 概述</a></h4>
<ul>
<li>
<p>局部变量表也被称之为局部变量数组或本地变量表</p>
</li>
<li>
<p>定义为一个<strong>数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型（8种）、对象引用（reference），以及returnAddress类型</p>
</li>
<li>
<p>由于局部变量表是建立在线程的栈上，是线程私有数据，因此<strong>不存在数据安全问题</strong></p>
</li>
<li>
<p><strong>局部变量表所需的容量大小是在编译起确定下来的</strong>，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表大小的</p>
</li>
<li>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</p>
</li>
<li>
<p>局部变量表的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</p>
<p>代码测试</p>
<pre><code class="language-java">package com.nasuf.jvm;

import java.util.Date;

public class LocalVariableTest {
    private int count = 0;

    public static void main(String[] args) {
        LocalVariableTest test = new LocalVariableTest();
        int num = 10;
        test.test1();
    }

    public void test1() {
        Date date = new Date();
        String name1 = &quot;nasuf&quot;;
        String info = test2(date, name1);
        System.out.println(date + name1);
    }
}
</code></pre>
<p>使用javap反编译后查看main方法部分输出如下：</p>
<pre><code class="language-java">    public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1    // 笔者注：此处locals=3表示局部变量表的最大容量为3
         0: new           #3                  // class com/nasuf/jvm/LocalVariableTest
         3: dup
         4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: bipush        10
        10: istore_2
        11: aload_1
        12: invokevirtual #5                  // Method test1:()V
        15: return
      LineNumberTable:
        line 9: 0
        line 10: 8
        line 11: 11
        line 12: 15
      LocalVariableTable:    // 笔者注：局部变量表
        Start  Length  Slot  Name   Signature
            0      16     0  args   [Ljava/lang/String;    // 笔者注：L表示引用类型，此处表示方法参数args
            8       8     1  test    Lcom/nasuf/jvm/LocalVariableTest;    // 笔者注： test表示局部变量test  
           11       5     2   num   I    // 笔者注：I表示Int类型，变量num
</code></pre>
<p>同样可以使用jclasslib查看字节码中main方法局部变量表的信息：
<img src="JVM//images/jvm/5/7.png" alt="image.png" />
<img src="JVM//images/jvm/5/8.png" alt="image.png" /></p>
<p>下图表示字节码指令的行号和Java代码行号的对应关系</p>
<p><img src="JVM//images/jvm/5/9.png" alt="image.png" /></p>
<p>结合下列字节码信息</p>
<p><img src="JVM//images/jvm/5/10.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/11.png" alt="image.png" /></p>
</li>
<li>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
</li>
<li>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p>
</li>
</ul>
<h4 id="132-关于slot的理解"><a class="header" href="#132-关于slot的理解">1.3.2 关于Slot的理解</a></h4>
<ul>
<li>
<p>参数值的存放总是在局部变量表数组的index0开始，到数组长度-1的索引结束</p>
</li>
<li>
<p>局部变量表，最基本的存储单元是slot（变量槽）</p>
</li>
<li>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</strong></p>
<ul>
<li>byte,short,char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
<p><img src="JVM//images/jvm/5/12.png" alt="image.png" /></p>
</li>
<li>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个Slot上</strong></p>
</li>
<li>
<p><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可</strong>。（比如：访问long或double类型变量）</p>
<p><img src="JVM//images/jvm/5/13.png" alt="image.png" /></p>
</li>
<li>
<p><strong>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的Slot处</strong>，其余的参数按照参数表顺序继续排列；对于静态方法，this变量不存在与当前方法的局部变量表中，因而无法使用this引用</p>
<p><img src="JVM//images/jvm/5/14.png" alt="image.png" /></p>
</li>
<li>
<p><strong>Slot是可以重用的</strong>。如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的</p>
<p><img src="JVM//images/jvm/5/15.png" alt="image.png" /></p>
</li>
</ul>
<h4 id="133-各类变量的对比"><a class="header" href="#133-各类变量的对比">1.3.3 各类变量的对比</a></h4>
<ul>
<li>
<p>Java变量分类：</p>
<ul>
<li>按照数据类型：
<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置：
<ul>
<li>成员变量 (在使用前，都经历过默认初始化赋值)：
<ul>
<li>静态变量（或称为类变量，在linking的prepare阶段，给类变量默认赋值；在initial阶段给类变量显式赋值，即静态代码块赋值）</li>
<li>实例变量（随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值)</li>
</ul>
</li>
<li>局部变量 (在使用前，必须要显式赋值，否则编译不通过；不存在系统默认初始化赋值过程)</li>
</ul>
</li>
</ul>
<p><img src="JVM//images/jvm/5/16.png" alt="image.png" /></p>
</li>
</ul>
<h3 id="14-操作数栈-operand-stack"><a class="header" href="#14-操作数栈-operand-stack">1.4 操作数栈 (Operand Stack)</a></h3>
<ul>
<li>每一个独立的栈帧中，除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为<strong>表达式栈（Expression Stack）</strong></li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈push/出栈pop
<ul>
<li>某些字节码指令将值亚茹操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈；比如执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<p><img src="JVM//images/jvm/5/17.png" alt="image.png" /></p>
<ul>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li>
<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></li>
<li>操作数栈就是JVM执行引擎的一个工作区，<strong>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</strong></li>
<li>每一个操作数栈都会有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了（<strong>操作数栈数据结构方面是用数组实现的</strong>），保存在方法的Code属性中，为max_stack的值
<img src="JVM//images/jvm/5/18.png" alt="image.png" />
使用javap反编译字节码后输出也可以查看操作数栈的最大深度：
<img src="JVM//images/jvm/5/19.png" alt="image.png" /></li>
<li>栈中的任何一个元素都可以是任意的Java数据类型
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈<strong>并非采用访问索引的方式进行数据访问</strong>，而是只能通过标准的入栈和出栈操作来完成一次数据访问</li>
</ul>
<h4 id="141-代码追踪"><a class="header" href="#141-代码追踪">1.4.1 代码追踪</a></h4>
<pre><code class="language-java">public class OperandStackTest {

    public void testAddOperation() {
        // byte, short, boolean, char都以int型进行保存
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}
</code></pre>
<p><img src="JVM//images/jvm/5/20.png" alt="image.png" /></p>
<p>字节码指令解析：</p>
<p><img src="JVM//images/jvm/5/21.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/22.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/23.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/24.png" alt="image.png" />
针对具有返回值的方法调用，则会执行<strong>aload_0</strong>指令，将调用的方法返回值直接入栈操作数栈；同时如果方法具有返回值（如int型)，则对应的字节码指令为<strong>ireturn</strong></p>
<p><img src="JVM//images/jvm/5/25.png" alt="image.png" /></p>
<h3 id="15-栈顶缓存技术-top-of-stack-cashing"><a class="header" href="#15-栈顶缓存技术-top-of-stack-cashing">1.5 栈顶缓存技术 (Top-of-Stack Cashing)</a></h3>
<ul>
<li>基于栈式架构的虚拟机所使用的的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读写次数</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</strong></li>
</ul>
<h3 id="16-动态链接-dynamic-linking"><a class="header" href="#16-动态链接-dynamic-linking">1.6 动态链接 (Dynamic Linking)</a></h3>
<ul>
<li>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的是支持当前方法的代码能够实现动态链接，比如：invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用 (Symbolic Reference) 保存在class文件的常量池里</strong>。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
<li><strong>字节码文件中的常量池在JVM运行后，放入到方法区，成为运行时常量池</strong></li>
</ul>
<p><img src="JVM//images/jvm/5/26.png" alt="image.png" /></p>
<p>比如针对下列代码：</p>
<pre><code class="language-java">public class DynamicLinkingTest {

    int num = 10;

    public void methodA() {
        System.out.println(&quot;methodA() ...&quot;);
    }

    public void methodB() {
        System.out.println(&quot;methodB() ...&quot;);
        methodA();
        num ++;
    }

}
</code></pre>
<p>使用javap编译字节码后部分输出:</p>
<p><img src="JVM//images/jvm/5/27.png" alt="image.png" /></p>
<p>其中#3，#6等表示的就是指向常量池中的符号引用。常量池的作用，就是为了提供一些符号和常量，便于指令的识别</p>
<p><img src="JVM//images/jvm/5/28.png" alt="image.png" /></p>
<h3 id="17-方法的调用"><a class="header" href="#17-方法的调用">1.7 方法的调用</a></h3>
<h4 id="171-概述"><a class="header" href="#171-概述">1.7.1 概述</a></h4>
<p>在JVM中，将符号引用转换为调用方法的直接引用，与方法的绑定机制有关</p>
<ul>
<li>静态链接。当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程，称之为静态链接</li>
<li>动态链接。如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接</li>
</ul>
<p>对应的方法绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</strong></p>
<ul>
<li>早期绑定，指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定。这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
<li>晚期绑定，指被调用的<strong>目标方法在编译期无法被确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法</strong>，这种绑定方式称之为晚期绑定</li>
</ul>
<p>代码演示</p>
<pre><code class="language-java">package com.nasuf.jvm;

class Animal {
    public void eat() {
        System.out.println(&quot;动物进食&quot;);
    }
}

interface Huntable {
    void hunt();
}

class Dog extends Animal implements Huntable {

    @Override
    public void eat() {
        System.out.println(&quot;狗吃骨头&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;狗捕食&quot;);
    }
}

class Cat extends Animal implements Huntable {

    public Cat() {
        super();    // 早期绑定
    }

    public Cat(String name) {
        this();     // 早期绑定
    }
    @Override
    public void eat() {
        super.eat();
        System.out.println(&quot;猫吃鱼&quot;);
    }

    @Override
    public void hunt() {
        System.out.println(&quot;猫捕食&quot;);
    }
}

public class AnimalTest {
    public void showAnimal(Animal animal) {
        animal.eat();   // 晚期绑定
    }

    public void showHun(Huntable h) {
        h.hunt();   // 晚期绑定
    }
}
</code></pre>
<p>查看AnimalTest类的字节码如下：</p>
<p><img src="JVM//images/jvm/5/29.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/30.png" alt="image.png" /></p>
<p>查看Cat类的字节码如下：</p>
<p><img src="JVM//images/jvm/5/31.png" alt="image.png" /></p>
<p><img src="JVM//images/jvm/5/32.png" alt="image.png" /></p>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持<strong>封装、继承和多态等面向对象特性</strong>，既然这一类编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p><strong>Java中任何一个普通的方法其实都具备虚函数的特征（即晚期绑定），他们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法（方法不允许重写，在编译期确定，不具备多态特征）</strong></p>
<h4 id="172-虚方法与非虚方法"><a class="header" href="#172-虚方法与非虚方法">1.7.2 虚方法与非虚方法</a></h4>
<p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为<strong>非虚方法</strong>。<strong>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</strong>，其他方法称为虚方法</p>
<p>虚拟机中提供了一下几条方法调用指令：</p>
<ul>
<li>普通调用指令：
<ul>
<li><strong>invokestatic</strong>: 调用静态方法，解析阶段确定唯一方法版本</li>
<li><strong>invokespecial</strong>: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li><strong>invokevirtual</strong>: 调用所有虚方法</li>
<li><strong>invokeinterface</strong>: 调用接口方法</li>
</ul>
</li>
<li>动态调用指令：
<ul>
<li><strong>invokedynamic</strong>: 动态解析出需要调用的方法，然后执行
<ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中财增加了一个invokedynamic指令，这是Java为了实现<strong>动态类型语言</strong>支持而做的一种改进</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令在Java中才有了直接的生成方式
<img src="JVM//images/jvm/5/33.png" alt="image.png" /></li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器
前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码及对应字节码指令解析如下：</p>
<pre><code class="language-java">package com.nasuf.jvm;

class Father {
    public Father() {
        System.out.println(&quot;father的构造器&quot;);
    }

    public static void showStatic(String str) {
        System.out.println(&quot;father &quot; + str);
    }

    public final void showFinal() {
        System.out.println(&quot;father show final&quot;);
    }

    public void showCommon() {
        System.out.println(&quot;father普通方法&quot;);
    }
}

public class Son extends Father {
    public Son() {
        // invokespecial 非虚方法
        super();
    }

    public Son (int age) {
        // invokespecial 非虚方法
        this();
    }

    /**
     * 静态方法不能被重写，尽管此处的方法签名跟父类方法完全一致
     * @param str
     */
    public static void showStatic(String str) {
        System.out.println(&quot;son &quot; + str);
    }

    private void showPrivate(String str) {
        System.out.println(&quot;son private &quot; + str);
    }

    public void show() {
        // invokestatic 非虚方法
        showStatic(&quot;nasuf&quot;);

        // invokestatic 非虚方法
        super.showStatic(&quot;good&quot;);

        // invokespecial 非虚方法
        showPrivate(&quot;hello&quot;);

        // invokespecial 非虚方法
        super.showCommon();

        // invokevirtual 因为showFinal()方法为父类的final方法，不能被子类重写，
        // 所以此处依然是非虚方法
        showFinal();
        // 如果明确引用父类的showFinal()方法，则此处对应的字节码指令则变为invokespecial
        // super.showFinal()

        // invokevirtual 因为没有明确指定super.showCommon()，该方法可能被子类重写，在编译期无法确定
        // 因此为虚方法
        showCommon();

        // invokevirtual
        info();

        MethodInterface methodInterface = null;
        // invokeinterface 虚方法，在执行时必须被实现类实现
        methodInterface.methodA();
    }

    public void info() { }

    public void display(Father f) {
        f.showCommon();
    }

    public static void main(String[] args) {
        Son son =  new Son();
        son.show();
    }

}

interface MethodInterface {
    void methodA();
}
</code></pre>
<h4 id="173-动态类型语言和静态类型语言"><a class="header" href="#173-动态类型语言和静态类型语言">1.7.3 动态类型语言和静态类型语言</a></h4>
<p>两者的区别在于对类型的检查是在编译期还是再运行期，满足前者的就是静态类型语言，反之是动态类型语言。换言之，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。Java属于静态类型语言（函数式编程lambda表达式赋予Java动态语言的一些特性），Javascript/Python属于动态类型语言</p>
<h4 id="174-方法重写的本质"><a class="header" href="#174-方法重写的本质">1.7.4 方法重写的本质</a></h4>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常</li>
<li>否则，按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li>
</ol>
<p><strong>IllegalAccessError</strong>：程序试图访问或修改一个属性或调用一个方法，这个属性或方法没有权限访问。一般这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变</p>
<h4 id="175-虚方法表"><a class="header" href="#175-虚方法表">1.7.5 虚方法表</a></h4>
<ul>
<li>在面向对象的编程中，会很频繁地使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就很可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区简历一个<strong>虚方法表 (virtual method table)（非虚方法不会出现在表中）来实现。使用索引表来代替查找</strong></li>
<li><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</strong></li>
<li><strong>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕</strong></li>
</ul>
<p>举例1：</p>
<p><img src="JVM//images/jvm/5/34.png" alt="image.png" /></p>
<p>举例2：</p>
<p><img src="JVM//images/jvm/5/35.png" alt="image.png" />
代码：</p>
<pre><code class="language-java">package com.nasuf.jvm;

interface Friendly {
    void sayHello();
    void sayGoodbye();
}

class Dog {
    public void sayHello() { }
    
    public String toString() {
        return &quot;Dog&quot;;
    }
}

class Cat implements Friendly {

    public void eat() { }

    @Override
    public void sayHello() { }

    @Override
    public void sayGoodbye() { }

    protected void finalize() { }

    public String toString() {
        return &quot;Cat&quot;;
    }
}

class CockerSpaniel extends Dog implements Friendly {

    public void sayHello() {
        super.sayHello();
    }

    @Override
    public void sayGoodbye() { }
}

public class VirtualMethodTable {
}

</code></pre>
<p>Dog虚方法表</p>
<p><img src="JVM//images/jvm/5/36.png" alt="image.png" /></p>
<p>CockerSpaniel虚方法表</p>
<p><img src="JVM//images/jvm/5/37.png" alt="image.png" /></p>
<p>Cat虚方法表</p>
<p><img src="JVM//images/jvm/5/38.png" alt="image.png" /></p>
<h3 id="18-方法返回地址return-address"><a class="header" href="#18-方法返回地址return-address">1.8 方法返回地址（Return Address）</a></h3>
<ul>
<li>存放调用该方法的PC寄存器的值（PC寄存器中存储的是该方法要执行的下一条指令的值）</li>
<li>一个方法的结束，有两种方式：
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层方法调用者，简称<strong>正常完成出口</strong>；
<ul>
<li>一个方法在正常调用完成之后酒井需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean,byte,char,shor,int类型时使用）、lreturn、freturn、dreturn、areturn，另外还有一个return指令供声明为void的方法、实力初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
<li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
</li>
<li>无论哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</li>
<li>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</li>
<li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</strong></li>
</ul>
<pre><code class="language-java">package com.nasuf.jvm;

import java.io.FileReader;
import java.io.IOException;
import java.util.Date;

public class ReturnAddressTest {

    // 默认构造器也是return

    // ireturn
    public boolean methodBoolean() { return false; }

    // ireturn
    public byte methodByte() { return 0; }

    // ireturn
    public short methodShort() { return 0; }

    // ireturn
    public char methodChar() { return 'a'; }

    // ireturn
    public int methodInt() { return 0; }

    // lreturn
    public long methodLong() { return 0L; }

    // freturn
    public float methodFloat() { return 0.0f; }

    // dreturn
    public double methodDouble() { return 0.0; }

    // areturn:引用类型
    public String methodString() { return null; }

    // areturn:引用类型
    public Date methodDate() { return null; }

    // return
    public void methodVoid() { }

    static {
        int i = 10;
    }

    public void method2() {
        try {
            method1();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void method1() throws IOException {
        FileReader fis = new FileReader(&quot;test.txt&quot;);
        char[] cBuffer = new char[1024];
        int len;
        while((len = fis.read(cBuffer)) != -1) {
            String str = new String(cBuffer, 0, len);
            System.out.println(str);
        }
        fis.close();
    }
}
</code></pre>
<p>执行javap对应method2输出如下（注意<strong>Exception table</strong>）：</p>
<pre><code class="language-java">public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=2, args_size=1
         0: aload_0
         1: invokevirtual #2                  // Method method1:()V
         4: goto          12
         7: astore_1
         8: aload_1
         9: invokevirtual #4                  // Method java/io/IOException.printStackTrace:()V
        12: return
      Exception table:
         from    to  target type
             0     4     7   Class java/io/IOException    
      LineNumberTable:
        line 50: 0
        line 53: 4
        line 51: 7
        line 52: 8
        line 54: 12
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            8       4     1     e   Ljava/io/IOException;
            0      13     0  this   Lcom/nasuf/jvm/ReturnAddressTest;
      StackMapTable: number_of_entries = 2
        frame_type = 71 /* same_locals_1_stack_item */
          stack = [ class java/io/IOException ]
        frame_type = 4 /* same */
</code></pre>
<p>表明如果代码从字节码指令0到4的范围内（代码行号范围为50到53）出现异常，按照字节码指令7（代码行号51）的位置进行处理：
<img src="JVM//images/jvm/5/39.png" alt="image.png" /></p>
<h3 id="19-一些附加信息"><a class="header" href="#19-一些附加信息">1.9 一些附加信息</a></h3>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息</p>
<h3 id="110-面试题方法中定义的局部变量是否线程安全"><a class="header" href="#110-面试题方法中定义的局部变量是否线程安全">1.10 面试题：方法中定义的局部变量是否线程安全？</a></h3>
<p>代码解析：</p>
<pre><code class="language-java">package com.nasuf.jvm;

/**
 * StringBuilder本身不是线程安全的
 */
public class StringBuilderTest {

    /**
     * s1在方法内部声明，只在方法内部使用，是线程安全的
     */
    public static void method1() {
        StringBuilder s1 = new StringBuilder();
        s1.append(&quot;a&quot;);
        s1.append(&quot;b&quot;);
        // ...
    }

    /**
     * s2由方法外部传入，不是线程安全的
     */
    public static void method2(StringBuilder s2) {
        s2.append(&quot;a&quot;);
        s2.append(&quot;b&quot;);
    }

    /**
     * s3由方法返回，可能被其他线程调用，不是线程安全的
     */
    public static StringBuilder method3() {
        StringBuilder s3 = new StringBuilder();
        s3.append(&quot;a&quot;);
        s3.append(&quot;b&quot;);
        return s3;
    }

    /**
     * s4是线程安全的, 查看StringBuilder的toString()方法源码如下，实际上是返回了一个新String对象
     * 该对象本身是线程不安全的，因为返回给外部，会被其他线程调用
     *     @Override
     *     public String toString() {
     *         // Create a copy, don't share the array
     *         return new String(value, 0, count);
     *     }
     */
    public static String method4() {
        StringBuilder s4 = new StringBuilder();
        s4.append(&quot;a&quot;);
        s4.append(&quot;b&quot;);
        return s4.toString();
    }
}
</code></pre>
<h2 id="2-本地方法栈"><a class="header" href="#2-本地方法栈">2. 本地方法栈</a></h2>
<p><img src="JVM//images/jvm/5/40.png" alt="image.png" /></p>
<ul>
<li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></li>
<li>本地方法栈，也是<strong>线程私有</strong>的</li>
<li>允许被实现成固定或者可动态扩展的内存大小。在内存溢出方面是相同的
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackOverflowError</strong>异常</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的本地方法栈，那么Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>
</li>
<li>本地方法是使用C语言实现的</li>
<li><strong>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库</strong></li>
<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong>
<ul>
<li>本地方法可以通过本地接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li><strong>并不是所有的JVM都支持本地方法</strong>。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现</li>
<li><strong>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust系列笔记"><a class="header" href="#rust系列笔记">Rust系列笔记</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>在rust语言中，生命周期的概念和使用是重难点之一。让我们一步步来深入了解这个内容。</p>
<h2 id="一基本理解"><a class="header" href="#一基本理解">一、基本理解</a></h2>
<p>我们先来看下面一段代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x;
    {
        let y = 5;
        x = &amp;y;
    } // #1
    println!(&quot;x: {}&quot;, x); // #2
}</code></pre></pre>
<p>编译后输出如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0597]: `y` does not live long enough
 --&gt; src/main.rs:6:13
  |
6 |         x = &amp;y;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `y` dropped here while still borrowed
8 |     println!(&quot;x: {}&quot;, x);
  |                       - borrow later used here
<span class="boring">}</span></code></pre></pre>
<p>从编译错误输出可以看出，变量<code>y</code>的作用域在<code>#1</code>处结束，变量<code>x</code>拥有一个更大的作用域，在<code>#2</code>处结束，但是<code>x</code>引用了<code>y</code>，导致当<code>y</code>的作用域结束时，<code>x</code>指向的<code>y</code>的内存空间被释放，属于无效引用。这个例子其实是一个典型的悬垂引用。<strong>rust中的生命周期标注就是要避免这种悬垂引用产生的内存安全问题。</strong></p>
<p>我们来看下面这个具体的生命周期标注的例子是如何避免悬垂引用的。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from(&quot;xxxx&quot;);
    let result;
    {
        let y = String::from(&quot;xx&quot;);
        result = longest(x.as_str(), y.as_str());
    }
    println!(&quot;{}&quot;, result);
}

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>首先，直观理解我们可以看出，result最终应该引用的是变量<code>x</code>，而不是<code>y</code>，所以不应该出现悬垂引用问题。但是站在函数<code>longest(x: &amp;str, y: &amp;str)</code>调用方的角度来看，并不能保证调用方在传给该函数参数后，计算结果总是保证变量<code>x</code>的长度更长，也就是说代码依然可能返回<code>y</code>。所以编译上述代码时，编译错误是关于<code>longest(x: &amp;str, y: &amp;str)</code>函数的，<code>main</code>方法中没有编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0106]: missing lifetime specifier
  --&gt; src/main.rs:11:33
   |
11 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
11 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
   |           ++++     ++          ++          ++
<span class="boring">}</span></code></pre></pre>
<p>上述编译错误表明，我们需要显式给<code>longest(x: &amp;str, y: &amp;str)</code>函数标注<code>&lt;'a&gt;</code>也就是生命周期标注。该标注表明：<strong>两个函数入参和返回值参数，至少都应该活得和<code>a</code>一样长；而<code>a</code>具体表明的生命周期应该是等于两个入参和返回值中生命周期最短的那个</strong>。</p>
<p><strong>请注意，生命周期标注并不会改变参数的实际生命周期，只是站在函数本身来说，函数的调用方应该保证函数入参和返回值应该具有的生命周期范围；如果不能保证那么编译器将拒绝该函数编译通过，继而无法执行。因此生命周期标注仅仅是为了告诉编译器，帮我检查该函数调用方是否符合函数要求的生命周期而已。</strong></p>
<p>现在我们按照提示修改<code>longest(x: &amp;str, y: &amp;str)</code>函数如下，<code>main</code>函数不做修改（<strong>请注意，生命周期标注属于参数类型的一部分，所以函数名后需要有类似泛型的标注，来表明<code>'a</code>是在说明参数类型</strong>）：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from(&quot;xxxx&quot;);
    let result;
    {
        let y = String::from(&quot;xx&quot;);
        result = longest(x.as_str(), y.as_str());
    } // #1
    println!(&quot;{}&quot;, result); // #2
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>再次编译后输出如下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0597]: `y` does not live long enough
 --&gt; src/main.rs:6:30
  |
6 |         result = longest(&amp;x, y.as_str());
  |                              ^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `y` dropped here while still borrowed
8 |     println!(&quot;{}&quot;, result);
  |                    ------ borrow later used here
<span class="boring">}</span></code></pre></pre>
<p>此时<code>main</code>函数会出现编译错误，提示变量<code>y</code>活得不够久，也就是作用域结束太早，出现了悬垂引用问题。</p>
<p>我们来分析一下：首先<code>longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str</code>函数签名表明所有入参和返回值的生命周期应该是三者中最小的那个。此时，函数调用方中<code>x</code>变量在<code>#2</code>处被释放，<code>y</code>在<code>#1</code>处被释放，所以<code>'a</code>表示的生命周期应该是<code>y</code>变量的生命周期；同时，因为返回值的生命周期标注也是<code>'a</code>，所以返回值的生命周期也应该是<code>y</code>变量的生命周期。但是从代码可以看出，显然<code>result</code>作为函数的返回值，最终是在<code>#2</code>处被释放，需要的生命周期大于<code>y</code>变量的生命周期，所以最终编译器判定该函数调用方的参数和返回值不满足函数体所标注的生命周期，编译失败。</p>
<p>如果我们将<code>main</code>函数稍作修改如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from(&quot;xxxx&quot;); // #1
    let result;
    {
        let y = String::from(&quot;xx&quot;);
        result = longest(x.as_str(), y.as_str());
        println!(&quot;{}&quot;, result);
    } // #2
}</code></pre></pre>
<p>此时函数入参<code>x</code>和<code>y</code>以及返回值<code>result</code>皆在<code>#2</code>处被释放，实际生命周期跟函数标注所需要的生命周期相同，因此编译通过。</p>
<p>有一个问题需要注意，我们讨论的所谓“生命周期”，指的是<strong>变量被释放的位置</strong>，<strong>而非变量在整个程序中实际存活的时间</strong>。例如上述代码中，变量<code>x</code>是在<code>#1</code>处被定义，存活时间明显比变量<code>y</code>和<code>result</code>要长，但是他们同时在<code>#2</code>处被释放，因此满足<code>longest</code>函数的生命周期标注。 另外，我们在讨论生命周期的问题时，关注的是与所有权转移相关的情况，而如果单纯的是引用拷贝，不涉及所有权转移的情况下，生命周期问题不会影响编译过程。例如修改代码如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = &quot;xxx&quot;;
    let result;
    {
        let y = &quot;xx&quot;;
        result = longest(x, y);
    }
    println!(&quot;{}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>此时<code>x</code>和<code>y</code>都是字符串切片类型<code>&amp;str</code>，变量<code>result</code>最终只是获取到了<code>x</code>或<code>y</code>字符串切片引用拷贝，不涉及所有权转移，因此上述生命周期的分析过程不再适用，也不会出现编译问题。</p>
<h2 id="二深入理解生命周期标注"><a class="header" href="#二深入理解生命周期标注">二、深入理解生命周期标注</a></h2>
<p>如上文所述，函数的生命周期标注并不会影响参数和返回值的实际生命周期，只是为了让编译器知道调用者应该满足的条件，否则编译失败。</p>
<p>另外，返回值的生命周期来源只能有两种：</p>
<ul>
<li><strong>函数入参的生命周期</strong></li>
<li><strong>函数内部自建引用的生命周期</strong></li>
</ul>
<p>函数入参的生命周期比较好理解，由于函数生命周期标注能够将函数的入参和返回值关联起来，那么当返回值只与某一部分函数入参相关时，我们无需将所有函数入参都进行生命周期标注。例如如下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = String::from(&quot;xxx&quot;);
    let result;
    {
        let y = String::from(&quot;xx&quot;);
        result = longest(x.as_str(), y.as_str());
    }
    println!(&quot;{}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    println!(&quot;{}, {}&quot;, x, y);
    x
}</code></pre></pre>
<p>由于函数<code>longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str)</code>返回值仅与参数<code>x</code>有关，参数<code>y</code>无需进行生命周期标注。</p>
<p>而使用函数内部自建引用的生命周期进行返回值的生命周期标注，就会产生悬垂引用的问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let t = String::from(&quot;xx&quot;);
    &amp;t
}
<span class="boring">}</span></code></pre></pre>
<p>编译错误如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0515]: cannot return reference to local variable `t`
  --&gt; src/main.rs:13:5
   |
13 |     &amp;t
   |     ^^ returns a reference to data owned by the current function
<span class="boring">}</span></code></pre></pre>
<h2 id="三结构体生命周期标注"><a class="header" href="#三结构体生命周期标注">三、结构体生命周期标注</a></h2>
<p>与函数体的生命周期标注类似，结构体也需要对引用类型进行生命周期标注：</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;'a&gt; {
    test: &amp;'a str,
}

fn main() {
    let x = String::from(&quot;xxx&quot;);
    let foo = Foo { test: x.as_str() };
    println!(&quot;{}&quot;, foo.test);
}</code></pre></pre>
<p><strong>该生命周期标注表明，引用类型<code>test</code>不能比结构体引用被释放得更早</strong>。如果我们将代码修改如下：</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;'a&gt; {
    test: &amp;'a str,
}

fn main() {
    let foo;
    {
        let x = String::from(&quot;xxx&quot;);
        foo = Foo { test: x.as_str() };
    } // #1
    println!(&quot;{}&quot;, foo.test); // #2
}</code></pre></pre>
<p>变量<code>x</code>在<code>#1</code>处被释放，而结构体引用<code>foo</code>在<code>#2</code>处被释放，<code>x</code>存活的时间比结构体引用要短，所以编译报错：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:9:27
   |
9  |         foo = Foo { test: x.as_str() };
   |                           ^^^^^^^^^^ borrowed value does not live long enough
10 |     } // #1
   |     - `x` dropped here while still borrowed
11 |     println!(&quot;{}&quot;, foo.test); // #2
   |                    -------- borrow later used here
<span class="boring">}</span></code></pre></pre>
<h2 id="四生命周期标注消除规则"><a class="header" href="#四生命周期标注消除规则">四、生命周期标注消除规则</a></h2>
<p>rust规定每一个引用类型的参数或返回值都必须具有生命周期。但是日常在代码编写过程中，我们并不一定需要显式标注。rust为我们提供了三条消除规则，以便在某些情况下避免手动标注生命周期（生命周期还是有的，只是无需开发者标注而已）。其中第一条是针对输入参数，第二条和第三条针对输出参数。</p>
<blockquote>
<p>（一）每一个引用参数都具有各自的生命周期（针对输入参数）</p>
</blockquote>
<p>例如函数<code>fn foo(x: &amp;'a str)</code>只存在一个输入参数，编译器会自动给其标注<code>'a</code>生命周期；当函数存在多个输入参数，它们各自也会被编译器标注各自的生命周期：<code>fn foo(x: &amp;'a str, y: &amp;'b str)</code></p>
<blockquote>
<p>（二）如果函数只存在一个输入参数，那么该输入参数的生命周期将自动被赋给所有输出参数</p>
</blockquote>
<p>例如函数<code>fn foo(x: &amp;'a str) -&gt; &amp;'a str {...}</code>只存在一个输入参数<code>x</code>，则其生命周期<code>'a</code>将被自动赋给输出参数也即返回值。</p>
<blockquote>
<p>（三）如果函数存在多个输入参数，但是包含了<code>&amp;self</code>或者<code>&amp;mut self</code>，那么该<code>self</code>引用的生命周期将被赋给所有输出参数</p>
</blockquote>
<p>存在<code>&amp;self</code>或<code>&amp;mut self</code>输入参数的函数称为方法(<code>method</code>)。例如方法<code>fn new(x: &amp;'a self, y: &amp;i32) -&gt; &amp;'a i32 {...}</code>，输出参数具有输入参数<code>&amp;self</code>相同的生命周期<code>'a</code>。此处需要再次强调，这是编译器默认标注的生命周期，假如方法实际的输出参数生命周期跟<code>&amp;self</code>并不相同，则需要进行显式标注。具体细节在下一节阐述。</p>
<h2 id="五方法的生命周期标注"><a class="header" href="#五方法的生命周期标注">五、方法的生命周期标注</a></h2>
<p>由于生命周期属于参数类型的一部分，所以方法的生命周期标注类似于泛型的使用。在泛型中，我们可以做如下定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    x: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>类似地，当结构体包含了引用类型的参数时，为其实现方法的语法也应该注意生命周期的标注。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self, y: &amp;str) -&gt; &amp;str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>但是注意，具体的方法在默认情况下，不需要进行额外的生命周期标注也能通过编译器编译，这是由于上一节中提到的生命周期标注消除规则的第一条和第三条，编译器为方法自动标注了生命周期。具体过程如下：首先根据第一条规则，编译器会给方法的每个输入参数都各自标记生命周期<code>'a</code>和<code>'b</code>；然后根据第三条规则，为输出参数标记输入参数<code>&amp;self</code>的生命周期<code>'a</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x&lt;'b&gt;(&amp;'a self, y: &amp;'b str) -&gt; &amp;'a str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>由于上述标注是编译器在编译时自动进行的，我们实际代码就可以简化如下，方法签名中不包含任何生命周期标注：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self, y: &amp;str) -&gt; &amp;str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>但是假如我们实际代码要求返回值的生命周期不为<code>'a</code>，而是<code>'b</code>，也就是说现在如果我们显式给输入参数和输出参数标注生命周期，且与编译器默认的标注不同时：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x&lt;'b&gt;(&amp;'a self, y: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>会得到如下编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error: lifetime may not live long enough
 --&gt; src/main.rs:8:9
  |
5 | impl&lt;'a&gt; Foo&lt;'a&gt; {
  |      -- lifetime `'a` defined here
6 |     fn x&lt;'b&gt;(&amp;'a self, y: &amp;'b str) -&gt; &amp;'b str {
  |          -- lifetime `'b` defined here
7 |         println!(&quot;{}&quot;, y);
8 |         &amp;self.x
  |         ^^^^^^^ method was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`
  |
  = help: consider adding the following bound: `'a: 'b`
<span class="boring">}</span></code></pre></pre>
<p>由于<code>&amp;self</code>的生命周期为<code>'a</code>，那么<code>&amp;self.x</code>的生命周期也为<code>'a</code>，所以当<code>&amp;self.x</code>作为方法返回值时，返回值的生命周期也应该为<code>'a</code>，但是此时我们给方法返回值标注的生命周期为<code>'b</code>。假如<code>'b</code>生命周期比<code>'a</code>长，也就是说返回给方法调用者的<code>&amp;self.x</code>活得比<code>&amp;self</code>更久。而当<code>&amp;self</code>引用被释放后，原本<code>&amp;self.x</code>也应该不存在，可是现在实际上的引用<code>&amp;self.x</code>的生命周期<code>'b</code>依然存活，因为我们假定的是<code>'b</code>长于<code>'a</code>，所以这种假定就是不合理的。因此我们需要假定并告知编译器<code>'a</code>长于<code>'b</code>。这里有两种写法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a: 'b, 'b&gt; Foo&lt;'a&gt; {
    fn x(&amp;'a self, y: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<p>其中<code>'a: 'b</code>表明生命周期<code>'a</code>长于<code>'b</code>；另一种写法是：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, 'b&gt; Foo&lt;'a&gt;
where
    'a: 'b,
{
    fn x(&amp;'a self, y: &amp;'b str) -&gt; &amp;'b str {
        println!(&quot;{}&quot;, y);
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="六泛型--生命周期标注"><a class="header" href="#六泛型--生命周期标注">六、泛型 + 生命周期标注</a></h2>
<p>最后我们来看一个相对综合的例子，结合了泛型和生命周期的标注语法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, z: T) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;{}&quot;, z);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
